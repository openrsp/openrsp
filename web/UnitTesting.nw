\section{Unit Testing\index{Unit testing}}
\label{section-unit-testing}

\subsection{Testing C APIs}

We first implement perturbations and its callback function for unit testing:
<<OpenRSPTestPerturbations.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of perturbations.

  2014-07-31, Bin Gao:
  * first version
*/

#include "OpenRSP.h"

#define NUM_ALL_PERT 3
extern const QcPertInt PERT_GEOMETRIC;
extern const QcPertInt PERT_DIPOLE;
extern const QcPertInt PERT_MAGNETIC;
extern const QInt MAX_ORDER_GEOMETRIC;
extern const QInt MAX_ORDER_DIPOLE;
extern const QInt MAX_ORDER_MAGNETIC;
<<OpenRSPTestPerturbations.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPTestPerturbations.h"

const QcPertInt PERT_GEOMETRIC = 1;
const QcPertInt PERT_DIPOLE = 2;
const QcPertInt PERT_MAGNETIC = 5;
const QInt MAX_ORDER_GEOMETRIC = 7;
const QInt MAX_ORDER_DIPOLE = 1;
const QInt MAX_ORDER_MAGNETIC = 7;
@ Here we have used three different perturbation labels for geometric, dipole
length and magnetic perturbations.

<<OpenRSPPertCallback.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of perturbations' callback function.

  2014-07-31, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_PERT_CALLBACK_H)
#define OPENRSP_PERT_CALLBACK_H

#include "OpenRSP.h"

extern void get_pert_concatenation(const QInt,
                                   const QcPertInt,
                                   const QInt,
                                   const QInt,
                                   const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   void*,
#endif
                                   QInt*);

#endif
<<OpenRSPPertCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPPertCallback.h"

void get_pert_concatenation(const QInt pert_label,
                            const QcPertInt first_cat_comp,
                            const QInt num_cat_comps,
                            const QInt num_sub_tuples,
                            const QInt *len_sub_tuples,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void *user_ctx,
#endif
                            QInt *rank_sub_comps)
{
}
@

We next implement callback functions for AO-based response theory calculations:
<<OpenRSPAODensCallback.h>>=
/*
  <<OpenRSPLicense>>

  This header file contains callback functions for AO-based response theory
  calculations.

  2015-10-16, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_AO_DENS_CALLBACK_H)
#define OPENRSP_AO_DENS_CALLBACK_H

#include "OpenRSP.h"

#if defined(ZERO_BASED_NUMBERING)
#define IDX_BLOCK_ROW 0
#define IDX_BLOCK_COL 0
#define IDX_FIRST_ROW 0
#define IDX_FIRST_COL 0
#else
#define IDX_BLOCK_ROW 1
#define IDX_BLOCK_COL 1
#define IDX_FIRST_ROW 1
#define IDX_FIRST_COL 1
#endif

extern void get_overlap_mat(const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QcMat*[]);
extern void get_overlap_exp(const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QReal*);
extern void get_one_oper_mat(const QInt,
                             const QcPertInt*,
                             const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QcMat*[]);
extern void get_one_oper_exp(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QReal*);
extern void get_two_oper_mat(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QcMat*[]);
extern void get_two_oper_exp(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             const QInt*,
                             QcMat*[],
                             const QInt*,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QReal*);
extern void get_nuc_contrib(const QInt,
                            const QcPertInt*,
                            const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QReal*);
extern void get_linear_rsp_solution(const QInt,
                                    const QReal*,
                                    const QInt,
                                    QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                                    void*,
#endif
                                    QcMat*[]);

#endif
@ Here we mimic callback functions by saving different AO-based matrices
calculated from Dalton program. These matrices are save in the directory
[[tests/ao_dens_ground_state_hf]], [[tests/ao_dens_alpha_hf]].
<<OpenRSPAODensCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPAODensCallback.h"

void get_overlap_mat(const QInt bra_num_pert,
                     const QcPertInt *bra_pert_labels,
                     const QInt *bra_pert_orders,
                     const QInt ket_num_pert,
                     const QcPertInt *ket_pert_labels,
                     const QInt *ket_pert_orders,
                     const QInt oper_num_pert,
                     const QcPertInt *oper_pert_labels,
                     const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt num_int,
                     QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_ground_state_hf/overlap_integrals.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context;
#endif
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QBool assembled;
    QInt imat;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    overlap_context = (char *)user_ctx;
    if (strcmp(overlap_context, "OVERLAP")!=0) {
        printf("get_overlap_mat>> incorrect operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    /* overlap integrals */
    if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==0) {
        /* checks if the matrix is assembled or not */
        ierr = QcMatIsAssembled(val_int[0], &assembled);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatIsAssembled");
            exit(ierr);
        }
        if (assembled==QFALSE) {
            ierr = QcMatBlockCreate(val_int[0], 1);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatBlockCreate");
                exit(ierr);
            }
            ierr = QcMatSetSymType(val_int[0], QSYMMAT);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetSymType");
                exit(ierr);
            }
            ierr = QcMatSetDataType(val_int[0],
                                    1,
                                    idx_block_row,
                                    idx_block_col,
                                    data_type);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetDataType");
                exit(ierr);
            }
            ierr = QcMatSetDimMat(val_int[0], NUM_AO, NUM_AO);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetDimMat");
                exit(ierr);
            }
            ierr = QcMatAssemble(val_int[0]);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatAssemble");
                exit(ierr);
            }
        }
        ierr = QcMatSetValues(val_int[0],
                              IDX_BLOCK_ROW,
                              IDX_BLOCK_COL,
                              IDX_FIRST_ROW,
                              NUM_AO,
                              IDX_FIRST_COL,
                              NUM_AO,
                              values_overlap,
                              NULL);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetValues");
            exit(ierr);
        }
    }
    else if (oper_num_pert==1 && bra_num_pert==0 && ket_num_pert==0) {
        if (oper_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero integrals */
        else if (oper_pert_labels[0]==PERT_DIPOLE) {
            for (imat=0; imat<num_int; imat++) {
                /* checks if the matrix is assembled or not */
                ierr = QcMatIsAssembled(val_int[imat], &assembled);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatIsAssembled");
                    exit(ierr);
                }
                if (assembled==QFALSE) {
                    ierr = QcMatBlockCreate(val_int[imat], 1);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatBlockCreate");
                        exit(ierr);
                    }
                    ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetSymType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDataType(val_int[imat],
                                            1,
                                            idx_block_row,
                                            idx_block_col,
                                            data_type);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDataType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDimMat");
                        exit(ierr);
                    }
                    ierr = QcMatAssemble(val_int[imat]);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAssemble");
                        exit(ierr);
                    }
                }
                ierr = QcMatZeroEntries(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatZeroEntries");
                    exit(ierr);
                }
            }
        }
        else if (oper_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_mat>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==1 && ket_num_pert==0) {
        if (bra_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero integrals */
        else if (bra_pert_labels[0]==PERT_DIPOLE) {
            for (imat=0; imat<num_int; imat++) {
                /* checks if the matrix is assembled or not */
                ierr = QcMatIsAssembled(val_int[imat], &assembled);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatIsAssembled");
                    exit(ierr);
                }
                if (assembled==QFALSE) {
                    ierr = QcMatBlockCreate(val_int[imat], 1);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatBlockCreate");
                        exit(ierr);
                    }
                    ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetSymType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDataType(val_int[imat],
                                            1,
                                            idx_block_row,
                                            idx_block_col,
                                            data_type);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDataType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDimMat");
                        exit(ierr);
                    }
                    ierr = QcMatAssemble(val_int[imat]);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAssemble");
                        exit(ierr);
                    }
                }
                ierr = QcMatZeroEntries(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatZeroEntries");
                    exit(ierr);
                }
            }
        }
        else if (bra_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_mat>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==1) {
        if (ket_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero integrals */
        else if (ket_pert_labels[0]==PERT_DIPOLE) {
            for (imat=0; imat<num_int; imat++) {
                /* checks if the matrix is assembled or not */
                ierr = QcMatIsAssembled(val_int[imat], &assembled);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatIsAssembled");
                    exit(ierr);
                }
                if (assembled==QFALSE) {
                    ierr = QcMatBlockCreate(val_int[imat], 1);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatBlockCreate");
                        exit(ierr);
                    }
                    ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetSymType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDataType(val_int[imat],
                                            1,
                                            idx_block_row,
                                            idx_block_col,
                                            data_type);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDataType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDimMat");
                        exit(ierr);
                    }
                    ierr = QcMatAssemble(val_int[imat]);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAssemble");
                        exit(ierr);
                    }
                }
                ierr = QcMatZeroEntries(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatZeroEntries");
                    exit(ierr);
                }
            }
        }
        else if (ket_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_mat>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
        printf("get_overlap_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
}

void get_overlap_exp(const QInt bra_num_pert,
                     const QcPertInt *bra_pert_labels,
                     const QInt *bra_pert_orders,
                     const QInt ket_num_pert,
                     const QcPertInt *ket_pert_labels,
                     const QInt *ket_pert_orders,
                     const QInt oper_num_pert,
                     const QcPertInt *oper_pert_labels,
                     const QInt *oper_pert_orders,
                     const QInt num_dens,
                     QcMat *ao_dens[],
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt num_exp,
                     QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_ground_state_hf/overlap_integrals.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context;
#endif
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QcMat val_int[1];
    QInt idens;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    overlap_context = (char *)user_ctx;
    if (strcmp(overlap_context, "OVERLAP")!=0) {
        printf("get_overlap_mat>> incorrect operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    /* overlap integrals */
    if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==0) {
        ierr = QcMatCreate(&val_int[0]);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatCreate");
            exit(ierr);
        }
        ierr = QcMatBlockCreate(&val_int[0], 1);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatBlockCreate");
            exit(ierr);
        }
        ierr = QcMatSetSymType(&val_int[0], QSYMMAT);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetSymType");
            exit(ierr);
        }
        ierr = QcMatSetDataType(&val_int[0],
                                1,
                                idx_block_row,
                                idx_block_col,
                                data_type);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetDataType");
            exit(ierr);
        }
        ierr = QcMatSetDimMat(&val_int[0], NUM_AO, NUM_AO);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetDimMat");
            exit(ierr);
        }
        ierr = QcMatAssemble(&val_int[0]);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatAssemble");
            exit(ierr);
        }
        ierr = QcMatSetValues(&val_int[0],
                              IDX_BLOCK_ROW,
                              IDX_BLOCK_COL,
                              IDX_FIRST_ROW,
                              NUM_AO,
                              IDX_FIRST_COL,
                              NUM_AO,
                              values_overlap,
                              NULL);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetValues");
            exit(ierr);
        }
        for (idens=0; idens<num_dens; idens++) {
            ierr = QcMatGetMatProdTrace(&val_int[0],
                                        ao_dens[idens],
                                        MAT_NO_OPERATION,
                                        1,
                                        &val_exp[2*idens]);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_exp>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatGetMatProdTrace");
                exit(ierr);
            }
        }
        ierr = QcMatDestroy(&val_int[0]);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatDestroy");
            exit(ierr);
        }
    }
    else if (oper_num_pert==1 && bra_num_pert==0 && ket_num_pert==0) {
        if (oper_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero integrals */
        else if (oper_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else if (oper_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==1 && ket_num_pert==0) {
        if (bra_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero integrals */
        else if (bra_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else if (bra_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==1) {
        if (ket_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero integrals */
        else if (ket_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else if (ket_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==1 && ket_num_pert==1) {
        /* zero integrals */
        if (bra_pert_labels[0]==PERT_DIPOLE || ket_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
         printf("get_overlap_exp>> not implemented at %s\n",
                FILE_AND_LINE);
         exit(QFAILURE);
    }
}

void get_one_oper_mat(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_int,
                      QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_alpha_hf/dipole_length_integrals.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *oneham_context = "ONEHAM";
    char *ext_field_context = "EXT_FIELD";
    char *one_oper_context;
#endif
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QBool assembled;
    QInt imat;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    one_oper_context = (char *)user_ctx;
    if (strcmp(one_oper_context, oneham_context)==0) {
        /* electric fields (zero integrals) */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            for (imat=0; imat<num_int; imat++) {
                /* checks if the matrix is assembled or not */
                ierr = QcMatIsAssembled(val_int[imat], &assembled);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatIsAssembled");
                    exit(ierr);
                }
                if (assembled==QFALSE) {
                    ierr = QcMatBlockCreate(val_int[imat], 1);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatBlockCreate");
                        exit(ierr);
                    }
                    ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetSymType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDataType(val_int[imat],
                                            1,
                                            idx_block_row,
                                            idx_block_col,
                                            data_type);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDataType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDimMat");
                        exit(ierr);
                    }
                    ierr = QcMatAssemble(val_int[imat]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAssemble");
                        exit(ierr);
                    }
                }
                ierr = QcMatZeroEntries(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatZeroEntries");
                    exit(ierr);
                }
            }
        }
        else {
            printf("get_one_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (strcmp(one_oper_context, ext_field_context)==0) {
        /* electric fields */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            /* checks if the matrix is assembled or not */
            for (imat=0; imat<num_int; imat++) {
                ierr = QcMatIsAssembled(val_int[imat], &assembled);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatIsAssembled");
                    exit(ierr);
                }
                if (assembled==QFALSE) {
                    ierr = QcMatBlockCreate(val_int[imat], 1);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatBlockCreate");
                        exit(ierr);
                    }
                    ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetSymType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDataType(val_int[imat],
                                            1,
                                            idx_block_row,
                                            idx_block_col,
                                            data_type);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDataType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDimMat");
                        exit(ierr);
                    }
                    ierr = QcMatAssemble(val_int[imat]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAssemble");
                        exit(ierr);
                    }
                }
            }
            /* dipole length integrals */
            if (oper_pert_orders[0]==1) {
                for (imat=0; imat<3; imat++) {
                    ierr = QcMatSetValues(val_int[imat],
                                          IDX_BLOCK_ROW,
                                          IDX_BLOCK_COL,
                                          IDX_FIRST_ROW,
                                          NUM_AO,
                                          IDX_FIRST_COL,
                                          NUM_AO,
                                          &values_diplen[imat*SIZE_AO_MAT],
                                          NULL);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetValues");
                        exit(ierr);
                    }
                }
            }
            /* zero integrals */
            else {
                for (imat=0; imat<3; imat++) {
                    ierr = QcMatZeroEntries(val_int[imat]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatZeroEntries");
                        exit(ierr);
                    }
                }
            }
        }
        else {
            printf("get_one_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
        printf("get_one_oper_mat>> unknown one-electron operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#else
    /* electric fields */
    if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        /* checks if the matrix is assembled or not */
        for (imat=0; imat<num_int; imat++) {
            ierr = QcMatIsAssembled(val_int[imat], &assembled);
            if (ierr!=QSUCCESS) {
                printf("get_one_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatIsAssembled");
                exit(ierr);
            }
            if (assembled==QFALSE) {
                ierr = QcMatBlockCreate(val_int[imat], 1);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatBlockCreate");
                    exit(ierr);
                }
                ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetSymType");
                    exit(ierr);
                }
                ierr = QcMatSetDataType(val_int[imat],
                                        num_blocks,
                                        idx_block_row,
                                        idx_block_col,
                                        data_type);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetDataType");
                    exit(ierr);
                }
                ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetDimMat");
                    exit(ierr);
                }
                ierr = QcMatAssemble(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatAssemble");
                    exit(ierr);
                }
            }
        }
        /* dipole length integrals */
        if (oper_pert_orders[0]==1) {
            for (imat=0; imat<3; imat++) {
                ierr = QcMatSetValues(val_int[imat],
                                      IDX_BLOCK_ROW,
                                      IDX_BLOCK_COL,
                                      IDX_FIRST_ROW,
                                      NUM_AO,
                                      IDX_FIRST_COL,
                                      NUM_AO,
                                      values_diplen[imat*SIZE_AO_MAT],
                                      NULL);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetValues");
                    exit(ierr);
                }
            }
        }
        /* zero integrals */
        else {
            for (imat=0; imat<3; imat++) {
                ierr = QcMatZeroEntries(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatZeroEntries");
                    exit(ierr);
                }
            }
        }
    }
    else {
        printf("get_one_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_one_oper_exp(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt num_dmat,
                      QcMat *dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_exp,
                      QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_alpha_hf/dipole_length_integrals.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *oneham_context = "ONEHAM";
    char *ext_field_context = "EXT_FIELD";
    char *one_oper_context;
#endif
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QcMat val_int[1];
    QInt offset_exp;
    QInt imat;
    QInt idens;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    one_oper_context = (char *)user_ctx;
    if (strcmp(one_oper_context, oneham_context)==0) {
        /* electric fields (zero integrals) */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else {
            printf("get_one_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (strcmp(one_oper_context, ext_field_context)==0) {
        /* electric fields */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            /* dipole length integrals */
            if (oper_pert_orders[0]==1) {
                offset_exp = 0;
                for (imat=0; imat<3; imat++) {
                    ierr = QcMatCreate(&val_int[0]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatCreate");
                        exit(ierr);
                    }
                    ierr = QcMatBlockCreate(&val_int[0], 1);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatBlockCreate");
                        exit(ierr);
                    }
                    ierr = QcMatSetSymType(&val_int[0], QSYMMAT);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetSymType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDataType(&val_int[0],
                                            1,
                                            idx_block_row,
                                            idx_block_col,
                                            data_type);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDataType");
                        exit(ierr);
                    }
                    ierr = QcMatSetDimMat(&val_int[0], NUM_AO, NUM_AO);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetDimMat");
                        exit(ierr);
                    }
                    ierr = QcMatAssemble(&val_int[0]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAssemble");
                        exit(ierr);
                    }
                    ierr = QcMatSetValues(&val_int[0],
                                          IDX_BLOCK_ROW,
                                          IDX_BLOCK_COL,
                                          IDX_FIRST_ROW,
                                          NUM_AO,
                                          IDX_FIRST_COL,
                                          NUM_AO,
                                          &values_diplen[imat*SIZE_AO_MAT],
                                          NULL);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatSetValues");
                        exit(ierr);
                    }
                    for (idens=0; idens<num_dmat; idens++) {
                        ierr = QcMatGetMatProdTrace(&val_int[0],
                                                    dens_mat[idens],
                                                    MAT_NO_OPERATION,
                                                    1,
                                                    &val_exp[offset_exp+2*idens]);
                        if (ierr!=QSUCCESS) {
                            printf("get_one_oper_exp>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling QcMatGetMatProdTrace");
                            exit(ierr);
                        }
                    }
                    ierr = QcMatDestroy(&val_int[0]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatDestroy");
                        exit(ierr);
                    }
                    offset_exp += 2*num_dmat;
                }
            }
            /* zero integrals */
            else {
                for (idens=0; idens<2*num_exp; idens++) {
                    val_exp[idens] = 0;
                }
            }
        }
        else {
            printf("get_one_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
        printf("get_one_oper_exp>> unknown one-electron operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#else
    /* electric fields */
    if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        /* dipole length integrals */
        if (oper_pert_orders[0]==1) {
            offset_exp = 0;
            for (imat=0; imat<3; imat++) {
                ierr = QcMatCreate(&val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatCreate");
                    exit(ierr);
                }
                ierr = QcMatBlockCreate(&val_int[0], 1);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatBlockCreate");
                    exit(ierr);
                }
                ierr = QcMatSetSymType(&val_int[0], QSYMMAT);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetSymType");
                    exit(ierr);
                }
                ierr = QcMatSetDataType(&val_int[0],
                                        1,
                                        idx_block_row,
                                        idx_block_col,
                                        data_type);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetDataType");
                    exit(ierr);
                }
                ierr = QcMatSetDimMat(&val_int[0], NUM_AO, NUM_AO);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetDimMat");
                    exit(ierr);
                }
                ierr = QcMatAssemble(&val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatAssemble");
                    exit(ierr);
                }
                ierr = QcMatSetValues(&val_int[0],
                                      IDX_BLOCK_ROW,
                                      IDX_BLOCK_COL,
                                      IDX_FIRST_ROW,
                                      NUM_AO,
                                      IDX_FIRST_COL,
                                      NUM_AO,
                                      values_diplen[imat*SIZE_AO_MAT],
                                      NULL);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetValues");
                    exit(ierr);
                }
                for (idens=0; idens<num_dmat; idens++) {
                    ierr = QcMatGetMatProdTrace(&val_int[0],
                                                dens_mat[idens],
                                                MAT_NO_OPERATION,
                                                1,
                                                &val_exp[offset_exp+2*idens]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatGetMatProdTrace");
                        exit(ierr);
                    }
                }
                ierr = QcMatDestroy(val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatDestroy");
                    exit(ierr);
                }
                offset_exp += 2*num_dmat;
            }
        }
        /* zero integrals */
        else {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
    else {
        printf("get_one_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_two_oper_mat(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt num_dmat,
                      QcMat *dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_int,
                      QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_alpha_hf/two_electron_integrals.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *two_oper_context;
#endif
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QBool assembled;
    QInt imat;
    QErrorCode ierr;
    static QInt id_gmat = -1;
#if defined(OPENRSP_C_USER_CONTEXT)
    two_oper_context = (char *)user_ctx;
    if (strcmp(two_oper_context, "NONLAO")!=0) {
        printf("get_two_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    else {
        /* checks if the matrix is assembled or not */
        for (imat=0; imat<num_int; imat++) {
            ierr = QcMatIsAssembled(val_int[imat], &assembled);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatIsAssembled");
                exit(ierr);
            }
            if (assembled==QFALSE) {
                ierr = QcMatBlockCreate(val_int[imat], 1);
                if (ierr!=QSUCCESS) {
                    printf("get_two_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatBlockCreate");
                    exit(ierr);
                }
                ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
                if (ierr!=QSUCCESS) {
                    printf("get_two_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetSymType");
                    exit(ierr);
                }
                ierr = QcMatSetDataType(val_int[imat],
                                        1,
                                        idx_block_row,
                                        idx_block_col,
                                        data_type);
                if (ierr!=QSUCCESS) {
                    printf("get_two_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetDataType");
                    exit(ierr);
                }
                ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
                if (ierr!=QSUCCESS) {
                    printf("get_two_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatSetDimMat");
                    exit(ierr);
                }
                ierr = QcMatAssemble(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_two_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatAssemble");
                    exit(ierr);
                }
            }
        }
        /* unperturbed two-electron integrals */
        if (oper_num_pert==0) {
            id_gmat++;
            if (id_gmat>5) {
                printf("get_two_oper_mat>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
            ierr = QcMatSetValues(val_int[0],
                                  IDX_BLOCK_ROW,
                                  IDX_BLOCK_COL,
                                  IDX_FIRST_ROW,
                                  NUM_AO,
                                  IDX_FIRST_COL,
                                  NUM_AO,
                                  &values_gmat[id_gmat*SIZE_AO_MAT],
                                  NULL);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetValues");
                exit(ierr);
            }
        }
        /* electric fields (zero integrals) */
        else if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            for (imat=0; imat<num_int; imat++) {
                ierr = QcMatZeroEntries(val_int[imat]);
                if (ierr!=QSUCCESS) {
                    printf("get_two_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatZeroEntries");
                    exit(ierr);
                }
            }
        }
        else {
            printf("get_two_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
#else
    /* checks if the matrix is assembled or not */
    for (imat=0; imat<num_int; imat++) {
        ierr = QcMatIsAssembled(val_int[imat], &assembled);
        if (ierr!=QSUCCESS) {
            printf("get_two_oper_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatIsAssembled");
            exit(ierr);
        }
        if (assembled==QFALSE) {
            ierr = QcMatBlockCreate(val_int[imat], 1);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatBlockCreate");
                exit(ierr);
            }
            ierr = QcMatSetSymType(val_int[imat], QSYMMAT);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetSymType");
                exit(ierr);
            }
            ierr = QcMatSetDataType(val_int[imat],
                                    num_blocks,
                                    idx_block_row,
                                    idx_block_col,
                                    data_type);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetDataType");
                exit(ierr);
            }
            ierr = QcMatSetDimMat(val_int[imat], NUM_AO, NUM_AO);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatSetDimMat");
                exit(ierr);
            }
            ierr = QcMatAssemble(val_int[imat]);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatAssemble");
                exit(ierr);
            }
        }
    }
    /* unperturbed two-electron integrals */
    if (oper_num_pert==0) {
        id_gmat++;
        if (id_gmat>5) {
            printf("get_two_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        ierr = QcMatSetValues(val_int[0],
                              IDX_BLOCK_ROW,
                              IDX_BLOCK_COL,
                              IDX_FIRST_ROW,
                              NUM_AO,
                              IDX_FIRST_COL,
                              NUM_AO,
                              values_gmat[id_gmat*SIZE_AO_MAT],
                              NULL);
        if (ierr!=QSUCCESS) {
            printf("get_two_oper_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetValues");
            exit(ierr);
        }
    }
    /* electric fields (zero integrals) */
    else if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        for (imat=0; imat<num_int; imat++) {
            ierr = QcMatZeroEntries(val_int[imat]);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatZeroEntries");
                exit(ierr);
            }
        }
    }
    else {
        printf("get_two_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_two_oper_exp(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt dmat_len_tuple,
                      const QInt *num_LHS_dmat,
                      QcMat *LHS_dens_mat[],
                      const QInt *num_RHS_dmat,
                      QcMat *RHS_dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_exp,
                      QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *two_oper_context;
#endif
    QInt ival;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    two_oper_context = (char *)user_ctx;
    if (strcmp(two_oper_context, "NONLAO")!=0) {
        printf("get_two_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    else {
        /* electric fields */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            for (ival=0; ival<2*num_exp; ival++) {
                val_exp[ival] = 0;
            }
        }
        else {
            printf("get_two_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
#else
    /* electric fields */
    if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        for (ival=0; ival<2*num_exp; ival++) {
            val_exp[ival] = 0;
        }
    }
    else {
        printf("get_two_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_nuc_contrib(const QInt nuc_num_pert,
                     const QcPertInt *nuc_pert_labels,
                     const QInt *nuc_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT) 
                     void *user_ctx,
#endif
                     const QInt size_pert,
                     QReal *val_nuc)
{
}

void get_linear_rsp_solution(const QInt size_pert,
                             const QReal *freq_sums,
                             const QInt num_freq_sums,
                             QcMat *RHS_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void *user_ctx,
#endif
                             QcMat *rsp_param[])
{
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_alpha_hf/response_parameters.h"
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QBool assembled;
    QErrorCode ierr;
    static QInt id_rsp_param = -1;
    id_rsp_param++;
    if (id_rsp_param>2) {
        printf("get_linear_rsp_solution>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    /* checks if the matrix is assembled or not */
    ierr = QcMatIsAssembled(rsp_param[0], &assembled);
    if (ierr!=QSUCCESS) {
        printf("get_linear_rsp_solution>> error happened at %s: %s\n",
               FILE_AND_LINE,
               "calling QcMatIsAssembled");
        exit(ierr);
    }
    if (assembled==QFALSE) {
        ierr = QcMatBlockCreate(rsp_param[0], 1);
        if (ierr!=QSUCCESS) {
            printf("get_linear_rsp_solution>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatBlockCreate");
            exit(ierr);
        }
        ierr = QcMatSetDataType(rsp_param[0],
                                1,
                                idx_block_row,
                                idx_block_col,
                                data_type);
        if (ierr!=QSUCCESS) {
            printf("get_linear_rsp_solution>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetDataType");
            exit(ierr);
        }
        ierr = QcMatSetDimMat(rsp_param[0], NUM_AO, NUM_AO);
        if (ierr!=QSUCCESS) {
            printf("get_linear_rsp_solution>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatSetDimMat");
            exit(ierr);
        }
        ierr = QcMatAssemble(rsp_param[0]);
        if (ierr!=QSUCCESS) {
            printf("get_linear_rsp_solution>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatAssemble");
            exit(ierr);
        }
    }
    ierr = QcMatSetValues(rsp_param[0],
                          IDX_BLOCK_ROW,
                          IDX_BLOCK_COL,
                          IDX_FIRST_ROW,
                          NUM_AO,
                          IDX_FIRST_COL,
                          NUM_AO,
                          &alpha_rsp_param[id_rsp_param*SIZE_AO_MAT],
                          NULL);
    if (ierr!=QSUCCESS) {
        printf("get_linear_rsp_solution>> error happened at %s: %s\n",
               FILE_AND_LINE,
               "calling QcMatSetValues");
        exit(ierr);
    }
}

@ The atomic-orbital density matrix-based response theory is tested by:
<<OpenRSPAODensTest.h>>=
/*
  <<OpenRSPLicense>>

   This is the header file of unit testing of the AO density matrix-based
   response theory.

   2014-07-31, Bin Gao
   * first version
*/
#if !defined(OPENRSP_AO_DENS_TEST_H)
#define OPENRSP_AO_DENS_TEST_H

#include "OpenRSPPertCallback.h"
#include "OpenRSPAODensCallback.h"

extern QErrorCode OpenRSPAODensTest(OpenRSP*,FILE*);

#endif
<<OpenRSPAODensTest.c>>=
/*
  <<OpenRSPLicense>>

   This file tests the AO density matrix-based response theory.

   2014-07-31, Bin Gao
   * first version
*/

#include "OpenRSPAODensTest.h"

QErrorCode OpenRSPAODensTest(OpenRSP *open_rsp, FILE *fp_log)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    /* user defined context of linear response equation solver */
    char *solver_context = "SOLVER";
#endif
    /* overlap integrals with London atomic orbitals */
    QInt overlap_num_pert = 2;
    QcPertInt overlap_pert_labels[2] = {PERT_GEOMETRIC,PERT_MAGNETIC};
    QInt overlap_pert_orders[2] = {MAX_ORDER_GEOMETRIC,MAX_ORDER_MAGNETIC};
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context = "OVERLAP";
#endif
    /* one-electron Hamiltonian */
    QInt oneham_num_pert = 2;
    QcPertInt oneham_pert_labels[2] = {PERT_GEOMETRIC,PERT_MAGNETIC};
    QInt oneham_pert_orders[2] = {MAX_ORDER_GEOMETRIC,MAX_ORDER_MAGNETIC};
#if defined(OPENRSP_C_USER_CONTEXT)
    char *oneham_context = "ONEHAM";
#endif
    /* external field */
    QInt ext_field_num_pert = 3;
    QcPertInt ext_field_pert_labels[3] = {PERT_GEOMETRIC,PERT_DIPOLE,PERT_MAGNETIC};
    QInt ext_field_pert_orders[3] = {MAX_ORDER_GEOMETRIC,MAX_ORDER_DIPOLE,MAX_ORDER_MAGNETIC};
#if defined(OPENRSP_C_USER_CONTEXT)
    char *ext_field_context = "EXT_FIELD";
#endif
    /* two-electron Hamiltonian */
    QInt twoel_num_pert = 2;
    QcPertInt twoel_pert_labels[2] = {PERT_GEOMETRIC,PERT_MAGNETIC};
    QInt twoel_pert_orders[2] = {MAX_ORDER_GEOMETRIC,MAX_ORDER_MAGNETIC};
#if defined(OPENRSP_C_USER_CONTEXT)
    char *twoel_context = "NONLAO";
#endif
    /* referenced state */
#include "ao_dens_ground_state_hf/num_atomic_orbitals.h"
#include "ao_dens_ground_state_hf/fock_matrix.h"
#include "ao_dens_ground_state_hf/density_matrix.h"
#include "ao_dens_ground_state_hf/overlap_integrals.h"
    QInt idx_block_row[1] = {IDX_BLOCK_ROW};
    QInt idx_block_col[1] = {IDX_BLOCK_COL};
    QcDataType data_type[1] = {QREALMAT};
    QcMat F_unpert;
    QcMat D_unpert;
    QcMat S_unpert;
    /* polarizability */
    QInt ALPHA_NUM_PROPS = 1;
    QInt ALPHA_LEN_TUPLE[1] = {2};
    QcPertInt ALPHA_PERT_TUPLE[2] = {PERT_DIPOLE,PERT_DIPOLE};
    QInt ALPHA_NUM_FREQ_CONFIGS[1] = {1};
    QReal ALPHA_PERT_FREQS[4] = {-0.072,0.0,0.072,0.0};
    QInt ALPHA_KN_RULES[1] = {0};
    /* response functions */
    QInt size_rsp_funs;
    QReal rsp_funs[18];
    QInt ipert,jpert,ival;
    /* error information */
    QErrorCode ierr;

    ///* sets the equation of motion of electrons */
    //ierr = OpenRSPSetElecEOM(open_rsp, ELEC_AO_D_MATRIX);
    //QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetElecEOM");
    //fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPSetElecEOM() passed\n");

    /* sets the context of linear response equation solver */
    ierr = OpenRSPSetLinearRSPSolver(open_rsp,
#if defined(OPENRSP_C_USER_CONTEXT)
                                     (void *)solver_context,
#endif
                                     &get_linear_rsp_solution);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetLinearRSPSolver");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPSetLinearRSPSolver() passed\n");

    /* sets the context of perturbation dependent basis sets */
    ierr = OpenRSPSetOverlap(open_rsp,
                             overlap_num_pert,
                             overlap_pert_labels,
                             overlap_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)overlap_context,
#endif
                             &get_overlap_mat,
                             &get_overlap_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetOverlap");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPSetOverlap() passed\n");

    /* adds one-electron Hamiltonian */
    ierr = OpenRSPAddOneOper(open_rsp,
                             oneham_num_pert,
                             oneham_pert_labels,
                             oneham_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)oneham_context,
#endif
                             &get_one_oper_mat,
                             &get_one_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddOneOper(h)");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPAddOneOper(h) passed\n");

    /* adds external field */
    ierr = OpenRSPAddOneOper(open_rsp,
                             ext_field_num_pert,
                             ext_field_pert_labels,
                             ext_field_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)ext_field_context,
#endif
                             &get_one_oper_mat,
                             &get_one_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddOneOper(V)");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPAddOneOper(V) passed\n");

    /* adds two-electron Hamiltonian */
    ierr = OpenRSPAddTwoOper(open_rsp,
                             twoel_num_pert,
                             twoel_pert_labels,
                             twoel_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)twoel_context,
#endif
                             &get_two_oper_mat,
                             &get_two_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddTwoOper()");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPAddTwoOper() passed\n");

    /* assembles the context of response theory calculations */
    ierr = OpenRSPAssemble(open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAssemble");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPAssemble() passed\n");

    /* writes the context of response theory calculations */
    ierr = OpenRSPWrite(open_rsp, "OpenRSPAODensTest.log");
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPWrite");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPWrite() passed\n");

    /* sets the unperturbed Fock matrix */
    ierr = QcMatCreate(&F_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate(F)");
    ierr = QcMatBlockCreate(&F_unpert, 1);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate(F)");
    ierr = QcMatSetSymType(&F_unpert, QSYMMAT);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetSymType(F)");
    ierr = QcMatSetDataType(&F_unpert, 1, idx_block_row, idx_block_col, data_type);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType(F)");
    ierr = QcMatSetDimMat(&F_unpert, NUM_AO, NUM_AO);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat(F)");
    ierr = QcMatAssemble(&F_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble(F)");
    ierr = QcMatSetValues(&F_unpert,
                          IDX_BLOCK_ROW,
                          IDX_BLOCK_COL,
                          IDX_FIRST_ROW,
                          NUM_AO,
                          IDX_FIRST_COL,
                          NUM_AO,
                          values_fock,
                          NULL);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetValues(F)");
    /* sets the unperturbed density matrix */
    ierr = QcMatCreate(&D_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate(D)");
    ierr = QcMatBlockCreate(&D_unpert, 1);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate(D)");
    ierr = QcMatSetSymType(&D_unpert, QSYMMAT);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetSymType(D)");
    ierr = QcMatSetDataType(&D_unpert, 1, idx_block_row, idx_block_col, data_type);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType(D)");
    ierr = QcMatSetDimMat(&D_unpert, NUM_AO, NUM_AO);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat(D)");
    ierr = QcMatAssemble(&D_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble(D)");
    ierr = QcMatSetValues(&D_unpert,
                          IDX_BLOCK_ROW,
                          IDX_BLOCK_COL,
                          IDX_FIRST_ROW,
                          NUM_AO,
                          IDX_FIRST_COL,
                          NUM_AO,
                          values_density,
                          NULL);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetValues(D)");
    /* sets the unperturbed overlap integrals */
    ierr = QcMatCreate(&S_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate(S)");
    ierr = QcMatBlockCreate(&S_unpert, 1);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate(S)");
    ierr = QcMatSetSymType(&S_unpert, QSYMMAT);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetSymType(S)");
    ierr = QcMatSetDataType(&S_unpert, 1, idx_block_row, idx_block_col, data_type);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType(S)");
    ierr = QcMatSetDimMat(&S_unpert, NUM_AO, NUM_AO);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat(S)");
    ierr = QcMatAssemble(&S_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble(S)");
    ierr = QcMatSetValues(&S_unpert,
                          IDX_BLOCK_ROW,
                          IDX_BLOCK_COL,
                          IDX_FIRST_ROW,
                          NUM_AO,
                          IDX_FIRST_COL,
                          NUM_AO,
                          values_overlap,
                          NULL);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetValues(S)");

    /* gets the polarizability */
    size_rsp_funs = 9;
    ierr = OpenRSPGetRSPFun(open_rsp,
                            &F_unpert,
                            &D_unpert,
                            &S_unpert,
                            ALPHA_NUM_PROPS,
                            ALPHA_LEN_TUPLE,
                            ALPHA_PERT_TUPLE,
                            ALPHA_NUM_FREQ_CONFIGS,
                            ALPHA_PERT_FREQS,
                            ALPHA_KN_RULES,
                            size_rsp_funs,
                            rsp_funs);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPGetRSPFun");
    fprintf(fp_log, "OpenRSPAODensTest>> OpenRSPGetRSPFun() passed\n");
    for (ipert=0,ival=0; ipert<3; ipert++) {
        for (jpert=0; jpert<3; jpert++) {
            fprintf(fp_log, " (%f,%f)", rsp_funs[ival], rsp_funs[ival+1]);
            ival += 2;
        }
        fprintf(fp_log, "\n");
    }

    /* cleans */
    ierr = QcMatDestroy(&F_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(F)");
    ierr = QcMatDestroy(&D_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(D)");
    ierr = QcMatDestroy(&S_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(S)");

    return QSUCCESS;
}

<<OpenRSPTest.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of OpenRSP unit testing.

  2014-07-31, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_TEST_H)
#define OPENRSP_TEST_H

#include <string.h>
#include "OpenRSP.h"

#include "OpenRSPAODensTest.h"

#endif

<<OpenRSPTest.c>>=
/*
  <<OpenRSPLicense>>

   This file tests the APIs of OpenRSP library.

   2014-07-31, Bin Gao
   * first version
*/

#include "OpenRSPTest.h"

/* <macrodef name='OPENRSP_TEST_EXECUTABLE'>
     Build test suite as excutables.
   </macrodef> */
#if defined(OPENRSP_TEST_EXECUTABLE)
QErrorCode main()
{
    FILE *fp_log=stdout;  /* file pointer */
#else
QErrorCode test_c_OpenRSP(FILE *fp_log)
{
#endif
#include "OpenRSPTestPerturbations.h"
    OpenRSP open_rsp;                                 /* context of response theory calculations */
    const QcPertInt ALL_PERT_LABELS[NUM_ALL_PERT] = {      /* labels of all perturbations */
        PERT_GEOMETRIC,PERT_DIPOLE,PERT_MAGNETIC};
    const QInt ALL_PERT_MAX_ORDERS[NUM_ALL_PERT] = {  /* maximum allowed orders of all perturbations */
        MAX_ORDER_GEOMETRIC,MAX_ORDER_DIPOLE,MAX_ORDER_MAGNETIC};
    const QInt ALL_PERT_SIZES[] = {                   /* sizes of all perturbations up to their maximum orders */
        12,78,364,1365,4368,12376,31824,              /* geometric derivatives (4 atoms) */
        3,                                            /* electric dipole */
        3,6,10,15,21,28,36};                          /* magnetic derivatives */
#if defined(OPENRSP_C_USER_CONTEXT)
    char *pert_context = "NRNZGEO";                  /* user defined context for perturbations */
#endif
    QErrorCode ierr;                                  /* error information */
    const QInt NUM_ATOMS = 4;

    /* creates the context of response theory calculations */
    ierr = OpenRSPCreate(&open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPCreate");
    fprintf(fp_log, "test_c_OpenRSP>> OpenRSPCreate() passed\n");

    /* sets information of all perturbations */
    ierr = OpenRSPSetPerturbations(&open_rsp,
                                   NUM_ALL_PERT,
                                   ALL_PERT_LABELS,
                                   ALL_PERT_MAX_ORDERS,
                                   ALL_PERT_SIZES,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   (void *)pert_context,
#endif
                                   &get_pert_concatenation);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetPerturbations");
    fprintf(fp_log, "test_c_OpenRSP>> OpenRSPSetPerturbations() passed\n");

    /* sets the nuclear Hamiltonian */
    ierr = OpenRSPSetNucHamilton(&open_rsp,
                                 NUM_ALL_PERT,
                                 ALL_PERT_LABELS,
                                 ALL_PERT_MAX_ORDERS,
#if defined(OPENRSP_C_USER_CONTEXT)   
                                 (void *)pert_context,
#endif
                                 &get_nuc_contrib,
                                 NUM_ATOMS);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetNucHamilton");
    fprintf(fp_log, "test_c_OpenRSP>> OpenRSPSetNucHamilton() passed\n");

    /* tests the density matrix-based response theory */
    ierr = OpenRSPAODensTest(&open_rsp, fp_log);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAODensTest");
    fprintf(fp_log, "test_c_OpenRSP>> density matrix-based response theory passed\n");

    /* destroys the context of response theory calculations */
    ierr = OpenRSPDestroy(&open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPDestroy");
    fprintf(fp_log, "test_c_OpenRSP>> OpenRSPDestroy() passed\n");

    return QSUCCESS;
}
@

\subsection{Testing Fortran APIs}

<<OpenRSPTest.F90>>=
!! <QcLang='Fortran'>
<<OpenRSPLicenseFortran>>
!!
!! This file tests the Fortran APIs of OpenRSP library.
!!
!! 2014-08-03, Bin Gao
!! * first version

