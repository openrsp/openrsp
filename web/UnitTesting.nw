\section{Unit Testing\index{Unit testing}}
\label{section-unit-testing}

\subsection{Numerical reference data}
\label{subsection-reference-data}

To test \LibName, we mimic callback functions by reading different data files
[[*.dat]]. These files were obtained from calculations using Dalton program
for the following twisted hydrogen peroxide with STO-3G:
\begin{verbatim}
H   1.6701141465  -0.1122989688   1.8068721870
H  -0.7421983272  -1.5025093539  -1.8068589821
O   0.0475007085   0.0952594669  -1.3682817885
O  -0.1137549810   0.0064888625   1.3682805836
\end{verbatim}

For the time being, we have the following reference data at Hartree-Fock level
as shown in Table~\ref{table-H2O2-HF-STO-3G}.
\begin{table}[hbt]
  \centering
  \caption{Numerical reference data of the twisted hydrogen peroxide from
    Dalton program, calculated at Hartree-Fock level with STO-3G basis sets.}
  \label{table-H2O2-HF-STO-3G}
  \begin{tabular}{lll}
    \hline\hline
    Property(frequencies) & $k$ & Files\\
    \hline
    $\mathcal{L}_{k,0-k}^{g}(0)$ & $0$ & \texttt{tests/DMatHF/E1g}\\
    \hline
    $\mathcal{L}_{k,1-k}^{gg}(0,0)$ & $0$ & \texttt{tests/DMatHF/E2g}\\
    \hline
    $\mathcal{L}_{k,2-k}^{ggg}(0,0,0)$ & $0$ & \texttt{tests/DMatHF/E3gk0}\\
    \hline
    $\mathcal{L}_{k,2-k}^{ggg}(0,0,0)$ & $1$ & \texttt{tests/DMatHF/E3gk1}\\
    \hline
    $\mathcal{L}_{k,3-k}^{gggg}(0,0,0,0)$ & $1$ & \texttt{tests/DMatHF/E4g}\\
    \hline
    $\mathcal{L}_{k,0-k}^{f}(0)$ & $0$ & \texttt{tests/DMatHF/E1f}\\
    \hline
    $\mathcal{L}_{k,2-k}^{fff}(0,0,0)$ & $1$ & \texttt{tests/DMatHF/E3f}\\
    \hline
    $\mathcal{L}_{k,2-k}^{fff}(-2\omega,\omega,\omega)$ & $1$ & \texttt{tests/DMatHF/E3fww}\\
    \hline
    $\mathcal{L}_{k,2-k}^{fff}(-3\omega,\omega,2\omega)$ & $1$ & \texttt{tests/DMatHF/E3fw2w}\\
    \hline
    $\mathcal{L}_{k,4-k}^{fffff}(-2\omega,-\omega,0,\omega,2\omega)$ & $2$ & \texttt{tests/DMatHF/E5f}\\
    \hline
    $\mathcal{L}_{k,1-k}^{gf}(0,0)$ & $0$ & \texttt{tests/DMatHF/E1g1f}\\
    \hline
    $\mathcal{L}_{k,2-k}^{gff}(0,0,0)$ & $0$ & \texttt{tests/DMatHF/E1g2f}\\
    \hline
    $\mathcal{L}_{k,4-k}^{gffff}(0,-3\omega,\omega,\omega,\omega)$ & $0$ & \texttt{tests/DMatHF/E1g4fk0}\\
    \hline
    $\mathcal{L}_{k,4-k}^{gffff}(0,-3\omega,\omega,\omega,\omega)$ & $1$ & \texttt{tests/DMatHF/E1g4fk1}\\
    \hline
    $\mathcal{L}_{k,4-k}^{gggff}(0,0,0,-\omega,\omega)$ & $2$ & \texttt{tests/DMatHF/E3g2f}\\
    \hline
    $\mathcal{L}_{k,5-k}^{ggffff}(0,0,-\omega,-\omega,0,2\omega)$ & $1$ & \texttt{tests/DMatHF/E2g4f}\\
    \hline\hline
  \end{tabular}
\end{table}

During building, the following CMake file will generate lists of filenames
containing the above data files:
<<OpenRSPTestData.cmake>>=
# Generated by notangle -ROpenRSPTestData.cmake web/UnitTesting.nw > cmake/OpenRSPTestData.cmake
include_directories(${PROJECT_BINARY_DIR})
set(OPENRSP_TEST_DATA ${PROJECT_BINARY_DIR}/OpenRSPTestData.h)
file(WRITE ${OPENRSP_TEST_DATA} "#if !defined(OPENRSP_TEST_DATA_H)\n")
file(APPEND ${OPENRSP_TEST_DATA} "#define OPENRSP_TEST_DATA_H\n\n")
file(APPEND ${OPENRSP_TEST_DATA} "#include \"qcmatrix.h\"\n\n")
# function of reading matrices from a dat file
file(APPEND ${OPENRSP_TEST_DATA} "extern QErrorCode OpenRSPTestReadMat(const char*,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     const QInt,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     const QInt,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     QcMat*[]);\n\n")
# function of zeroing matrices
file(APPEND ${OPENRSP_TEST_DATA} "extern QErrorCode OpenRSPTestZeroMat(const QInt,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     QcMat*[]);\n\n")
# atomic-orbital (AO) density matrix-based response theory
#
# unperturbed AO-based Fock matrix
get_filename_component(DMAT_HF_FOCK
                       ${LIB_OPENRSP_PATH}/tests/DMatHF/FOCK.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define DMAT_HF_FOCK \"${DMAT_HF_FOCK}\"\n")
# unperturbed AO-based density matrix
get_filename_component(DMAT_HF_DENSITY
                       ${LIB_OPENRSP_PATH}/tests/DMatHF/DENSITY.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define DMAT_HF_DENSITY \"${DMAT_HF_DENSITY}\"\n")
# unperturbed AO-based overlap integral matrix
get_filename_component(DMAT_OVERLAP
                       ${LIB_OPENRSP_PATH}/tests/DMatHF/OVERLAP.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define DMAT_OVERLAP \"${DMAT_OVERLAP}\"\n")
# unperturbed AO-based dipole length integral matrices
get_filename_component(DMAT_DIPLEN
                       ${LIB_OPENRSP_PATH}/tests/DMatHF/DIPLEN.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define DMAT_DIPLEN \"${DMAT_DIPLEN}\"\n")
# two-electron integrals contracted with perturbed AO-based density matrices
# for solving polarizability at frequency as 0.072
get_filename_component(ALPHA_GMAT_AO_HF
                       ${LIB_OPENRSP_PATH}/tests/AlphaGMatAOHF.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define ALPHA_GMAT_AO_HF \"${ALPHA_GMAT_AO_HF}\"\n")
# response parameters for solving polarizability at frequency as 0.072
get_filename_component(ALPHA_RSPARAM_AO_HF
                       ${LIB_OPENRSP_PATH}/tests/AlphaRSParamAOHF.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define ALPHA_RSPARAM_AO_HF \"${ALPHA_RSPARAM_AO_HF}\"\n")
file(APPEND ${OPENRSP_TEST_DATA} "\n#endif\n")
@ The following file will read a [[*.dat]] file and put the data into matrices:
<<OpenRSPTestData.c>>=
/*
  <<OpenRSPLicense>>
*/

#if defined(QCMATRIX_SINGLE_PRECISION)
#define QCREAL_FMT "f"
#else
#define QCREAL_FMT "lf"
#endif

#include "OpenRSPTestData.h"

/* <function name='OpenRSPTestReadMat'
             attr='private'
             author='Bin Gao'
             date='2015-10-18'>
     Reads a dat file and puts the data into matrices
     <param name='file_mat' direction='in'>
       Name of the dat file
     </param>
     <param name='num_skip_mat' direction='in'>
       Number of the first few matrices to skip
     </param>
     <param name='num_read_mat' direction='in'>
       Number of matrices to read
     </param>
     <param name='mat_read' direction='inout'>
       Matrices read
     </param>
     <return>Error information</return>
   </function> */
QErrorCode OpenRSPTestReadMat(const char *file_mat,
                              const QInt num_skip_mat,
                              const QInt num_read_mat,
                              QcMat *mat_read[])
{
    FILE *fp_dat;          /* file pointer */
    QInt dat_num_read;     /* number of arguments read from the dat file */
    QInt dat_num_mat;      /* number of matrices in the dat file */
    QInt dat_num_row;      /* number of rows of matrices */
    QInt dat_num_col;      /* number of columns of matrices */
    QInt dat_num_val;      /* number of values of matrices */
    QReal *dat_real_elms;  /* elements of real part */
    QReal *dat_imag_elms;  /* elements of imaginary part */
    QInt imat;             /* incremental recorder over matrices */
    QInt ival;             /* incremental recorder over values */
    QErrorCode ierr;       /* error information */
    /* parameters for setting matrices */
    const QInt NUM_BLOCKS=1;
#if defined(ZERO_BASED_NUMBERING)
    const QInt IDX_BLOCK_ROW[]={0};
    const QInt IDX_BLOCK_COL[]={0};
    const QInt IDX_FIRST_ROW=0;
    const QInt IDX_FIRST_COL=0;
#else
    const QInt IDX_BLOCK_ROW[]={1};
    const QInt IDX_BLOCK_COL[]={1};
    const QInt IDX_FIRST_ROW=1;
    const QInt IDX_FIRST_COL=1;
#endif
    QcSymType sym_type;
    QcDataType data_type[1];
    fp_dat = fopen(file_mat, "r");
    if (fp_dat==NULL) {
        printf("OpenRSPTestReadMat>> file: %s\n", file_mat);
        QErrorExit(FILE_AND_LINE, "open the dat file");
    }
    /* reads the number of matrices */
    if (fscanf(fp_dat, "%"QINT_FMT"", &dat_num_mat)!=1) {
        QErrorExit(FILE_AND_LINE, "read number of matrices");
    }
    /* checks the number of matrices to read */
    if (num_skip_mat+num_read_mat>dat_num_mat) {
        printf("OpenRSPTestReadMat>> number of skipping matrices %"QINT_FMT"\n",
               num_skip_mat);
        printf("OpenRSPTestReadMat>> number of reading matrices %"QINT_FMT"\n",
               num_read_mat);
        printf("OpenRSPTestReadMat>> number of matrices on the file %"QINT_FMT"\n",
               dat_num_mat);
        QErrorExit(FILE_AND_LINE, "not enough matrices on the file");
    }
    /* skips the first few matrices, including the '\n' of the first line */
    dat_num_read = fgetc(fp_dat);
    for (imat=0; imat<num_skip_mat; imat++) {
        /*fscanf(fp_dat, "%*[^\n]\n", NULL);*/
        /* reads the information of matrix */
        dat_num_read = fscanf(fp_dat,
                              "%d %d %"QINT_FMT" %"QINT_FMT"",
                              &sym_type, &data_type[0], &dat_num_row, &dat_num_col);
        if (dat_num_read!=4) {
            printf("OpenRSPTestReadMat>> number of arguments read %"QINT_FMT"\n",
                   dat_num_read);
            QErrorExit(FILE_AND_LINE, "read information of matrix");
        }
        dat_num_read = fgetc(fp_dat);
        do {
            dat_num_read = fgetc(fp_dat);
        } while (dat_num_read!='\n');
        /* skips imaginary part */
        if (data_type[0]!=QREALMAT) {
            do {
                dat_num_read = fgetc(fp_dat);
            } while (dat_num_read!='\n');
        }
    }
    /* initializes the elments of imaginary part */
    dat_imag_elms = NULL;
    for (imat=0; imat<num_read_mat; imat++) {
        /* reads the information of matrix */
        dat_num_read = fscanf(fp_dat,
                              "%d %d %"QINT_FMT" %"QINT_FMT"",
                              &sym_type, &data_type[0], &dat_num_row, &dat_num_col);
        if (dat_num_read!=4) {
            printf("OpenRSPTestReadMat>> number of arguments read %"QINT_FMT"\n",
                   dat_num_read);
            QErrorExit(FILE_AND_LINE, "read information of matrix");
        }
        /* allocates memory for elements of real part */
        dat_num_val = dat_num_row*dat_num_col;
        dat_real_elms = (QReal *)malloc(dat_num_val*sizeof(QReal));
        if (dat_real_elms==NULL) {
            printf("OpenRSPTestReadMat>> matrix %"QINT_FMT"\n",
                   imat+num_skip_mat);
            printf("OpenRSPTestReadMat>> number of elements %"QINT_FMT"\n",
                   dat_num_val);
            QErrorExit(FILE_AND_LINE, "allocates memory for elements of real part");
        }
        /* reads elements of real part */
        for (ival=0; ival<dat_num_val; ival++) {
            if (fscanf(fp_dat, "%"QCREAL_FMT"", &dat_real_elms[ival])!=1) {
                printf("OpenRSPTestReadMat>> %"QINT_FMT"-th element\n", ival);
                QErrorExit(FILE_AND_LINE, "read elements of real part");
            }
        }
        if (data_type[0]!=QREALMAT) {
            /* allocates memory for elements of imaginary part */
            dat_imag_elms = (QReal *)malloc(dat_num_val*sizeof(QReal));
            if (dat_imag_elms==NULL) {
                printf("OpenRSPTestReadMat>> matrix %"QINT_FMT"\n",
                       imat+num_skip_mat);
                printf("OpenRSPTestReadMat>> number of elements %"QINT_FMT"\n",
                       dat_num_val);
                QErrorExit(FILE_AND_LINE, "allocates memory for elements of imaginary part");
            }
            /* reads elements of imaginary part */
            for (ival=0; ival<dat_num_val; ival++) {
                if (fscanf(fp_dat, "%"QCREAL_FMT"", &dat_imag_elms[ival])!=1) {
                    printf("OpenRSPTestReadMat>> %"QINT_FMT"-th element\n", ival);
                    QErrorExit(FILE_AND_LINE, "read elements of imaginary part");
                }
            }
        }
        /* creates the matrix */
        ierr = QcMatCreate(mat_read[imat]);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate()");
        ierr = QcMatBlockCreate(mat_read[imat], NUM_BLOCKS);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate()");
        ierr = QcMatSetSymType(mat_read[imat], sym_type);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetSymType()");
        ierr = QcMatSetDataType(mat_read[imat],
                                NUM_BLOCKS,
                                IDX_BLOCK_ROW,
                                IDX_BLOCK_COL,
                                data_type);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType()");
        ierr = QcMatSetDimMat(mat_read[imat], dat_num_row, dat_num_col);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat()");
        ierr = QcMatAssemble(mat_read[imat]);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble()");
        /* saves the values into the matrix */
        ierr = QcMatSetValues(mat_read[imat],
                              IDX_BLOCK_ROW[0],
                              IDX_BLOCK_COL[0],
                              IDX_FIRST_ROW,
                              dat_num_row,
                              IDX_FIRST_COL,
                              dat_num_col,
                              dat_real_elms,
                              dat_imag_elms);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetValues()");
        free(dat_real_elms);
        dat_real_elms = NULL;
        if (dat_imag_elms!=NULL) {
            free(dat_imag_elms);
            dat_imag_elms = NULL;
        }
    }
    fclose(fp_dat);
    return QSUCCESS;
}
@

%In the above code, we have used [[fscanf(fp_dat, "%*[^\n]\n", NULL);]] to
%skip the first few lines of the [[dat]] file. This is learnt from
%\href{http://stackoverflow.com/questions/2799612/how-to-skip-the-first-line-when-fscanning-a-txt-file}{How to skip the first line when fscanning a .txt file?}
%where
%\begin{quotation}
%the format string represent a line containing any character including spaces.
%The [[*]] in the format string and the [[NULL]] pointer mean we are not
%interested in saving the line, but just in incrementing the file position.
%\end{quotation}
%
%\begin{quotation}
%[[%]] is the character which each scanf format string starts with;
%[[*]] indicates to not put the found pattern anywhere (typically you save
%pattern found into parameters after the format string, in this case the
%parameter is [[NULL]]);
%[[[^\n]]] means any character except newline;
%[[\n]] means newline;
%
%So the [[[^\n]\n]] means a full text line ending with newline.
%\end{quotation}

The following function will zero out a few matrices:
<<OpenRSPTestData.c>>=
/* <function name='OpenRSPTestZeroMat'
             attr='private'
             author='Bin Gao'
             date='2015-10-18'>
     Zero out a few matrices
     <param name='num_mat' direction='in'>
       Number of matrices to be zeroed out
     </param>
     <param name='mat_zero' direction='inout'>
       Matrices to be zeroed out
     </param>
     <return>Error information</return>
   </function> */
QErrorCode OpenRSPTestZeroMat(const QInt num_mat, QcMat *mat_zero[])
{
    QInt imat;        /* incremental recorder over matrices */
    QErrorCode ierr;  /* error information */
    /* parameters for setting matrices */
    const QInt NUM_BLOCKS=1;
#if defined(ZERO_BASED_NUMBERING)
    const QInt IDX_BLOCK_ROW[]={0};
    const QInt IDX_BLOCK_COL[]={0};
#else
    const QInt IDX_BLOCK_ROW[]={1};
    const QInt IDX_BLOCK_COL[]={1};
#endif
    QcDataType DATA_TYPE[1]={QREALMAT};
    const QInt DAT_NUM_ROW=32;
    const QInt DAT_NUM_COL=32;
    for (imat=0; imat<num_mat; imat++) {
        ierr = QcMatCreate(mat_zero[imat]);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate()");
        ierr = QcMatBlockCreate(mat_zero[imat], NUM_BLOCKS);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate()");
        ierr = QcMatSetSymType(mat_zero[imat], QSYMMAT);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetSymType()");
        ierr = QcMatSetDataType(mat_zero[imat],
                                NUM_BLOCKS,
                                IDX_BLOCK_ROW,
                                IDX_BLOCK_COL,
                                DATA_TYPE);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType()");
        ierr = QcMatSetDimMat(mat_zero[imat], DAT_NUM_ROW, DAT_NUM_COL);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat()");
        ierr = QcMatAssemble(mat_zero[imat]);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble()");
        ierr = QcMatZeroEntries(mat_zero[imat]);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatZeroEntries()");
    }
    return QSUCCESS;
}

@

\subsection{Testing C APIs}

We first implement perturbations and its callback function for unit testing:
<<OpenRSPTestPerturbations.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of perturbations.

  2014-07-31, Bin Gao:
  * first version
*/

#include "OpenRSP.h"

#define NUM_ALL_PERT 3
#define PERT_GEOMETRIC 1
#define PERT_DIPOLE 2
#define PERT_MAGNETIC 5
#define MAX_ORDER_GEOMETRIC 7
#define MAX_ORDER_DIPOLE 1
#define MAX_ORDER_MAGNETIC 7

extern const QcPertInt ALL_PERT_LABELS[NUM_ALL_PERT];
extern const QInt ALL_PERT_MAX_ORDERS[NUM_ALL_PERT];
extern const QInt ALL_PERT_SIZES[15];
extern const QInt NUM_ATOMS;
<<OpenRSPTestPerturbations.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPTestPerturbations.h"

/* labels of all perturbations */
const QcPertInt ALL_PERT_LABELS[]={PERT_GEOMETRIC,
                                   PERT_DIPOLE,
                                   PERT_MAGNETIC};
/* allowed maximal orders of all perturbations */
const QInt ALL_PERT_MAX_ORDERS[]={MAX_ORDER_GEOMETRIC,
                                  MAX_ORDER_DIPOLE,
                                  MAX_ORDER_MAGNETIC};
/* sizes of all perturbations up to their maximal orders */
const QInt ALL_PERT_SIZES[]={
    12,78,364,1365,4368,12376,31824,  /* geometric derivatives (4 atoms) */
    3,                                /* electric dipole */
    3,6,10,15,21,28,36};              /* magnetic derivatives */
const QInt NUM_ATOMS=4;
@ Here we have used three different perturbation labels for geometric, dipole
length and magnetic perturbations.
<<OpenRSPPertCallback.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of perturbations' callback function.

  2014-07-31, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_PERT_CALLBACK_H)
#define OPENRSP_PERT_CALLBACK_H

#include "OpenRSP.h"

#if defined(OPENRSP_C_USER_CONTEXT)
#define PERT_CONTEXT "NRNZGEO"
#endif

extern void get_pert_concatenation(const QInt,
                                   const QcPertInt,
                                   const QInt,
                                   const QInt,
                                   const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   void*,
#endif
                                   QInt*);

#endif
<<OpenRSPPertCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPPertCallback.h"

void get_pert_concatenation(const QInt pert_label,
                            const QcPertInt first_cat_comp,
                            const QInt num_cat_comps,
                            const QInt num_sub_tuples,
                            const QInt *len_sub_tuples,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void *user_ctx,
#endif
                            QInt *rank_sub_comps)
{
/*FIXME: to implement*/
}
@

The following header and C files implement the callback function for
zero-electron operator (nuclear Hamiltonian):
<<OpenRSPZeroOperCallback.h>>=
/*
  <<OpenRSPLicense>>

  This header file contains callback function for zero-electron operator
  (nuclear Hamiltonian).

  2015-10-16, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_ZERO_OPER_CALLBACK_H)
#define OPENRSP_ZERO_OPER_CALLBACK_H

#include "OpenRSP.h"

#if defined(OPENRSP_C_USER_CONTEXT)
#define ZERO_OPER_CONTEXT "ZERO_OPER"
#endif

extern void get_zero_oper_contrib(const QInt,
                                  const QcPertInt*,
                                  const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                                  void*,
#endif
                                  const QInt,
                                  QReal*);

#endif
<<OpenRSPZeroOperCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPZeroOperCallback.h"

void get_zero_oper_contrib(const QInt oper_num_pert,
                           const QcPertInt *oper_pert_labels,
                           const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                           void *user_ctx,
#endif
                           const QInt size_pert,
                           QReal *val_oper)
{
/*FIXME: to implement*/
}
@

We next implement callback functions for AO-based response theory calculations:
<<OpenRSPDMatCallback.h>>=
/*
  <<OpenRSPLicense>>

  This header file contains callback functions for AO-based response theory
  calculations.

  2015-10-16, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_DMAT_CALLBACK_H)
#define OPENRSP_DMAT_CALLBACK_H

#include "OpenRSP.h"
#include "OpenRSPTestData.h"

#if defined(OPENRSP_C_USER_CONTEXT)
#define OVERLAP_CONTEXT "OVERLAP"
#define ONEHAM_CONTEXT "ONEHAM"
#define EXT_FIELD_CONTEXT "EXT_FIELD"
#define TWO_OPER_CONTEXT "NONLAO"
#define SOLVER_CONTEXT "SOLVER"
#endif

extern void get_overlap_mat(const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QcMat*[]);
extern void get_overlap_exp(const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QReal*);
extern void get_one_oper_mat(const QInt,
                             const QcPertInt*,
                             const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QcMat*[]);
extern void get_one_oper_exp(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QReal*);
extern void get_two_oper_mat(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QcMat*[]);
extern void get_two_oper_exp(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             const QInt*,
                             QcMat*[],
                             const QInt*,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QReal*);
extern void get_linear_rsp_solution(const QInt,
                                    const QInt*,
                                    const QInt*,
                                    const QReal*,
                                    QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                                    void*,
#endif
                                    QcMat*[]);

#endif
@ By using the functions developed in
Subsection~\ref{subsection-reference-data}, we can implement the following file
callback functions to read matrices from [[*.dat]] files for the AO-based
response theory calculations:
<<OpenRSPDMatCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPDMatCallback.h"

void get_overlap_mat(const QInt bra_num_pert,
                     const QcPertInt *bra_pert_labels,
                     const QInt *bra_pert_orders,
                     const QInt ket_num_pert,
                     const QcPertInt *ket_pert_labels,
                     const QInt *ket_pert_orders,
                     const QInt oper_num_pert,
                     const QcPertInt *oper_pert_labels,
                     const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt num_int,
                     QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context;
#endif
    QcMat **tmp_int;
    const QReal NUMBER_ONE[]={1.0,0.0};
    QBool zero_int;
    QErrorCode ierr;
    QInt ilab;
#if defined(OPENRSP_C_USER_CONTEXT)
    overlap_context = (char *)user_ctx;
    if (strcmp(overlap_context, OVERLAP_CONTEXT)!=0) {
        printf("get_overlap_mat>> incorrect operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    switch (oper_num_pert) {
    case 0:
        switch (bra_num_pert) {
        case 0:
            switch (ket_num_pert) {
            case 0:
                /* unperturbed AO-based overlap integral matrix */
                tmp_int = (QcMat **)malloc(sizeof(QcMat *));
                if (tmp_int==NULL) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "allocates memory for temporary matrix array");
                    exit(QFAILURE);
                }
                tmp_int[0] = (QcMat *)malloc(sizeof(QcMat));
                if (tmp_int[0]==NULL) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "allocates memory for temporary matrices");
                    exit(QFAILURE);
                }
                ierr = OpenRSPTestReadMat(DMAT_OVERLAP, 0, 1, tmp_int);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling OpenRSPTestReadMat()");
                    exit(ierr);
                }
                ierr = QcMatAXPY(NUMBER_ONE, tmp_int[0], val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatAXPY()");
                    exit(ierr);
                }
                ierr = QcMatDestroy(tmp_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatDestroy()");
                    exit(ierr);
                }
                free(tmp_int[0]);
                tmp_int[0] = NULL;
                free(tmp_int);
                tmp_int = NULL;
                break;
            default:
                zero_int = QFALSE;
                for (ilab=0; ilab<ket_num_pert; ilab++) {
                    if (ket_pert_labels[ilab]!=PERT_GEOMETRIC &&
                        ket_pert_labels[ilab]!=PERT_MAGNETIC) {
                        zero_int = QTRUE;
                        break;
                    }
                }
                if (zero_int==QFALSE) {
                    printf("get_overlap_mat>> not implemented at %s\n",
                           FILE_AND_LINE);
                    exit(QFAILURE);
                }
            }
            break;
        default:
            zero_int = QFALSE;
            for (ilab=0; ilab<bra_num_pert; ilab++) {
                if (bra_pert_labels[ilab]!=PERT_GEOMETRIC &&
                    bra_pert_labels[ilab]!=PERT_MAGNETIC) {
                    zero_int = QTRUE;
                    break;
                }
            }
            if (zero_int==QFALSE) {
                printf("get_overlap_mat>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
        }
        break;
    default:
        zero_int = QFALSE;
        for (ilab=0; ilab<oper_num_pert; ilab++) {
            if (oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
                oper_pert_labels[ilab]!=PERT_MAGNETIC) {
                zero_int = QTRUE;
                break;
            }
        }
        if (zero_int==QFALSE) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
}

void get_overlap_exp(const QInt bra_num_pert,
                     const QcPertInt *bra_pert_labels,
                     const QInt *bra_pert_orders,
                     const QInt ket_num_pert,
                     const QcPertInt *ket_pert_labels,
                     const QInt *ket_pert_orders,
                     const QInt oper_num_pert,
                     const QcPertInt *oper_pert_labels,
                     const QInt *oper_pert_orders,
                     const QInt num_dens,
                     QcMat *ao_dens[],
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt num_exp,
                     QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context;
#endif
    QcMat *val_int[1];
    QInt idens;
    QBool zero_int;
    QErrorCode ierr;
    QInt ilab;
#if defined(OPENRSP_C_USER_CONTEXT)
    overlap_context = (char *)user_ctx;
    if (strcmp(overlap_context, OVERLAP_CONTEXT)!=0) {
        printf("get_overlap_mat>> incorrect operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    switch (oper_num_pert) {
    case 0:
        switch (bra_num_pert) {
        case 0:
            switch (ket_num_pert) {
            case 0:
                /* unperturbed AO-based overlap integral matrix */
                val_int[0] = (QcMat *)malloc(sizeof(QcMat));
                if (val_int[0]==NULL) {
                    printf("get_overlap_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "allocats memory for matrix");
                    exit(QFAILURE);
                }
                ierr = OpenRSPTestReadMat(DMAT_OVERLAP, 0, 1, val_int);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling OpenRSPTestReadMat()");
                    exit(ierr);
                }
                for (idens=0; idens<num_dens; idens++) {
                    ierr = QcMatGetMatProdTrace(val_int[0],
                                                ao_dens[idens],
                                                MAT_NO_OPERATION,
                                                1,
                                                &val_exp[2*idens]);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatGetMatProdTrace");
                        exit(ierr);
                    }
                }
                ierr = QcMatDestroy(val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_overlap_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatDestroy()");
                    exit(ierr);
                }
                free(val_int[0]);
                val_int[0] = NULL;
                break;
            default:
                zero_int = QFALSE;
                for (ilab=0; ilab<ket_num_pert; ilab++) {
                    if (ket_pert_labels[ilab]!=PERT_GEOMETRIC &&
                        ket_pert_labels[ilab]!=PERT_MAGNETIC) {
                        zero_int = QTRUE;
                        break;
                    }
                }
                if (zero_int==QFALSE) {
                    printf("get_overlap_exp>> not implemented at %s\n",
                           FILE_AND_LINE);
                    exit(QFAILURE);
                }
            }
            break;
        default:
            zero_int = QFALSE;
            for (ilab=0; ilab<bra_num_pert; ilab++) {
                if (bra_pert_labels[ilab]!=PERT_GEOMETRIC &&
                    bra_pert_labels[ilab]!=PERT_MAGNETIC) {
                    zero_int = QTRUE;
                    break;
                }
            }
            if (zero_int==QFALSE) {
                printf("get_overlap_exp>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
        }
        break;
    default:
        zero_int = QFALSE;
        for (ilab=0; ilab<oper_num_pert; ilab++) {
            if (oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
                oper_pert_labels[ilab]!=PERT_MAGNETIC) {
                zero_int = QTRUE;
                break;
            }
        }
        if (zero_int==QFALSE) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
}

void get_one_oper_mat(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_int,
                      QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *one_oper_context;
#endif
    QcMat **tmp_int;
    const QReal NUMBER_ONE[]={1.0,0.0};
    QBool zero_int;
    QErrorCode ierr;
    QInt ilab;
#if defined(OPENRSP_C_USER_CONTEXT)
    one_oper_context = (char *)user_ctx;
    if (strcmp(one_oper_context, ONEHAM_CONTEXT)==0) {
        zero_int = QFALSE;
        for (ilab=0; ilab<oper_num_pert; ilab++) {
            if (oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
                oper_pert_labels[ilab]!=PERT_MAGNETIC) {
                zero_int = QTRUE;
                break;
            }
        }
        if (zero_int==QFALSE) {
            printf("get_one_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (strcmp(one_oper_context, EXT_FIELD_CONTEXT)==0) {
        zero_int = QFALSE;
        for (ilab=0; ilab<oper_num_pert; ilab++) {
            if ((oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
                 oper_pert_labels[ilab]!=PERT_MAGNETIC &&
                 oper_pert_labels[ilab]!=PERT_DIPOLE) ||
                (oper_pert_labels[ilab]==PERT_DIPOLE &&
                 oper_pert_orders[0]>1)) {
                zero_int = QTRUE;
                break;
            }
        }
        if (zero_int==QFALSE) {
            switch (oper_num_pert) {
            case 1:
                /* unperturbed AO-based dipole length integral matrices */
                if (oper_pert_labels[0]==PERT_DIPOLE && oper_pert_orders[0]==1) {
                    tmp_int = (QcMat **)malloc(3*sizeof(QcMat *));
                    if (tmp_int==NULL) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "allocates memory for temporary matrix array");
                        exit(QFAILURE);
                    }
                    for (ilab=0; ilab<3; ilab++) {
                        tmp_int[ilab] = (QcMat *)malloc(sizeof(QcMat));
                        if (tmp_int[ilab]==NULL) {
                            printf("get_one_oper_mat>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "allocates memory for temporary matrices");
                            exit(QFAILURE);
                        }
                    }
                    ierr = OpenRSPTestReadMat(DMAT_DIPLEN, 0, 3, tmp_int);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling OpenRSPTestReadMat()");
                        exit(ierr);
                    }
                    for (ilab=0; ilab<3; ilab++) {
                        ierr = QcMatAXPY(NUMBER_ONE, tmp_int[ilab], val_int[ilab]);
                        if (ierr!=QSUCCESS) {
                            printf("get_one_oper_mat>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling QcMatAXPY()");
                            exit(ierr);
                        }
                        ierr = QcMatDestroy(tmp_int[ilab]);
                        if (ierr!=QSUCCESS) {
                            printf("get_overlap_mat>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling QcMatDestroy()");
                            exit(ierr);
                        }
                        free(tmp_int[ilab]);
                        tmp_int[ilab] = NULL;
                    }
                    free(tmp_int);
                    tmp_int = NULL;
                }
                else {
                    printf("get_one_oper_mat>> not implemented at %s\n",
                           FILE_AND_LINE);
                    exit(QFAILURE);
                }
                break;
            default:
                printf("get_one_oper_mat>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
        }
    }
    else {
        printf("get_one_oper_mat>> unknown one-electron operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#else
    zero_int = QFALSE;
    for (ilab=0; ilab<oper_num_pert; ilab++) {
        if ((oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
             oper_pert_labels[ilab]!=PERT_MAGNETIC &&
             oper_pert_labels[ilab]!=PERT_DIPOLE) ||
            (oper_pert_labels[ilab]==PERT_DIPOLE &&
             oper_pert_orders[0]>1)) {
            zero_int = QTRUE;
            break;
        }
    }
    if (zero_int==QFALSE) {
        switch (oper_num_pert) {
        case 1:
            /* unperturbed AO-based dipole length integral matrices */
            if (oper_pert_labels[0]==PERT_DIPOLE && oper_pert_orders[0]==1) {
                tmp_int = (QcMat **)malloc(3*sizeof(QcMat *));
                if (tmp_int==NULL) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "allocates memory for temporary matrix array");
                    exit(QFAILURE);
                }
                for (ilab=0; ilab<3; ilab++) {
                    tmp_int[ilab] = (QcMat *)malloc(sizeof(QcMat));
                    if (tmp_int[ilab]==NULL) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "allocates memory for temporary matrices");
                        exit(QFAILURE);
                    }
                }
                ierr = OpenRSPTestReadMat(DMAT_DIPLEN, 0, 3, tmp_int);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling OpenRSPTestReadMat()");
                    exit(ierr);
                }
                for (ilab=0; ilab<3; ilab++) {
                    ierr = QcMatAXPY(NUMBER_ONE, tmp_int[ilab], val_int[ilab]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatAXPY()");
                        exit(ierr);
                    }
                    ierr = QcMatDestroy(tmp_int[ilab]);
                    if (ierr!=QSUCCESS) {
                        printf("get_overlap_mat>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatDestroy()");
                        exit(ierr);
                    }
                    free(tmp_int[ilab]);
                    tmp_int[ilab] = NULL;
                }
                free(tmp_int);
                tmp_int = NULL;
            }
            else {
                printf("get_one_oper_mat>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
            break;
        default:
            printf("get_one_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
#endif
}

void get_one_oper_exp(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt num_dmat,
                      QcMat *dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_exp,
                      QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *one_oper_context;
#endif
    QcMat *val_int[1];
    QBool zero_int;
    QInt offset_exp;
    QInt ilab;
    QInt idens;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    one_oper_context = (char *)user_ctx;
    if (strcmp(one_oper_context, ONEHAM_CONTEXT)==0) {
        zero_int = QFALSE;
        for (ilab=0; ilab<oper_num_pert; ilab++) {
            if (oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
                oper_pert_labels[ilab]!=PERT_MAGNETIC) {
                zero_int = QTRUE;
                break;
            }
        }
        if (zero_int==QFALSE) {
            printf("get_one_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (strcmp(one_oper_context, EXT_FIELD_CONTEXT)==0) {
        zero_int = QFALSE;
        for (ilab=0; ilab<oper_num_pert; ilab++) {
            if ((oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
                 oper_pert_labels[ilab]!=PERT_MAGNETIC &&
                 oper_pert_labels[ilab]!=PERT_DIPOLE) ||
                (oper_pert_labels[ilab]==PERT_DIPOLE &&
                 oper_pert_orders[0]>1)) {
                zero_int = QTRUE;
                break;
            }
        }
        if (zero_int==QFALSE) {
            switch (oper_num_pert) {
            case 1:
                /* unperturbed AO-based dipole length integral matrices */
                if (oper_pert_labels[0]==PERT_DIPOLE && oper_pert_orders[0]==1) {
                    val_int[0] = (QcMat *)malloc(sizeof(QcMat));
                    if (val_int[0]==NULL) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "allocats memory for matrix");
                        exit(QFAILURE);
                    }
                    offset_exp = 0;
                    for (ilab=0; ilab<3; ilab++) {
                        ierr = OpenRSPTestReadMat(DMAT_DIPLEN, ilab, 1, val_int);
                        if (ierr!=QSUCCESS) {
                            printf("get_one_oper_exp>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling OpenRSPTestReadMat()");
                            exit(ierr);
                        }
                        for (idens=0; idens<num_dmat; idens++) {
                            ierr = QcMatGetMatProdTrace(val_int[0],
                                                        dens_mat[idens],
                                                        MAT_NO_OPERATION,
                                                        1,
                                                        &val_exp[offset_exp+2*idens]);
                            if (ierr!=QSUCCESS) {
                                printf("get_one_oper_exp>> error happened at %s: %s\n",
                                       FILE_AND_LINE,
                                       "calling QcMatGetMatProdTrace()");
                                exit(ierr);
                            }
                        }
                        ierr = QcMatDestroy(val_int[0]);
                        if (ierr!=QSUCCESS) {
                            printf("get_one_oper_exp>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling QcMatDestroy()");
                            exit(ierr);
                        }
                        offset_exp += 2*num_dmat;
                    }
                    free(val_int[0]);
                    val_int[0] = NULL;
                }
                else {
                    printf("get_one_oper_exp>> not implemented at %s\n",
                           FILE_AND_LINE);
                    exit(QFAILURE);
                }
                break;
            default:
                printf("get_one_oper_exp>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
        }
    }
    else {
        printf("get_one_oper_exp>> unknown one-electron operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#else
    zero_int = QFALSE;
    for (ilab=0; ilab<oper_num_pert; ilab++) {
        if ((oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
             oper_pert_labels[ilab]!=PERT_MAGNETIC &&
             oper_pert_labels[ilab]!=PERT_DIPOLE) ||
            (oper_pert_labels[ilab]==PERT_DIPOLE &&
             oper_pert_orders[0]>1)) {
            zero_int = QTRUE;
            break;
        }
    }
    if (zero_int==QFALSE) {
        switch (oper_num_pert) {
        case 1:
            /* unperturbed AO-based dipole length integral matrices */
            if (oper_pert_labels[0]==PERT_DIPOLE && oper_pert_orders[0]==1) {
                val_int[0] = (QcMat *)malloc(sizeof(QcMat));
                if (val_int[0]==NULL) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "allocats memory for matrix");
                    exit(QFAILURE);
                }
                offset_exp = 0;
                for (ilab=0; ilab<3; ilab++) {
                    ierr = OpenRSPTestReadMat(DMAT_DIPLEN, ilab, 1, val_int);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling OpenRSPTestReadMat()");
                        exit(ierr);
                    }
                    for (idens=0; idens<num_dmat; idens++) {
                        ierr = QcMatGetMatProdTrace(val_int[0],
                                                    dens_mat[idens],
                                                    MAT_NO_OPERATION,
                                                    1,
                                                    &val_exp[offset_exp+2*idens]);
                        if (ierr!=QSUCCESS) {
                            printf("get_one_oper_exp>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling QcMatGetMatProdTrace()");
                            exit(ierr);
                        }
                    }
                    ierr = QcMatDestroy(val_int[0]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatDestroy()");
                        exit(ierr);
                    }
                    offset_exp += 2*num_dmat;
                }
                free(val_int[0]);
                val_int[0] = NULL;
            }
            else {
                printf("get_one_oper_exp>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
            break;
        default:
            printf("get_one_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
#endif
}

void get_two_oper_mat(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt num_dmat,
                      QcMat *dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_int,
                      QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *two_oper_context;
#endif
    QcMat **tmp_int;
    const QReal NUMBER_ONE[]={1.0,0.0};
    QBool zero_int;
    QErrorCode ierr;
    QInt ilab;
    static QInt id_gmat = -1;
#if defined(OPENRSP_C_USER_CONTEXT)
    two_oper_context = (char *)user_ctx;
    if (strcmp(two_oper_context, TWO_OPER_CONTEXT)!=0) {
        printf("get_two_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    zero_int = QFALSE;
    for (ilab=0; ilab<oper_num_pert; ilab++) {
        if (oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
            oper_pert_labels[ilab]!=PERT_MAGNETIC) {
            zero_int = QTRUE;
            break;
        }
    }
    if (zero_int==QFALSE) {
        /* two-electron integrals contracted with perturbed AO-based density
           matrices for solving polarizability at frequency as 0.072 */
        if (oper_num_pert==0) {
            id_gmat++;
            if (id_gmat>5) {
                printf("get_two_oper_mat>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
            tmp_int = (QcMat **)malloc(sizeof(QcMat *));
            if (tmp_int==NULL) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "allocates memory for temporary matrix array");
                exit(QFAILURE);
            }
            tmp_int[0] = (QcMat *)malloc(sizeof(QcMat));
            if (tmp_int[0]==NULL) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "allocates memory for temporary matrices");
                exit(QFAILURE);
            }
            ierr = OpenRSPTestReadMat(ALPHA_GMAT_AO_HF, id_gmat, 1, tmp_int);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestReadMat()");
                exit(ierr);
            }
            ierr = QcMatAXPY(NUMBER_ONE, tmp_int[0], val_int[0]);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatAXPY()");
                exit(ierr);
            }
            ierr = QcMatDestroy(tmp_int[0]);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatDestroy()");
                exit(ierr);
            }
            free(tmp_int[0]);
            tmp_int[0] = NULL;
            free(tmp_int);
            tmp_int = NULL;
        }
        else {
            printf("get_two_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
}

void get_two_oper_exp(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt dmat_len_tuple,
                      const QInt *num_LHS_dmat,
                      QcMat *LHS_dens_mat[],
                      const QInt *num_RHS_dmat,
                      QcMat *RHS_dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_exp,
                      QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *two_oper_context;
#endif
    QBool zero_int;
    QErrorCode ierr;
    QInt ilab;
#if defined(OPENRSP_C_USER_CONTEXT)
    two_oper_context = (char *)user_ctx;
    if (strcmp(two_oper_context, TWO_OPER_CONTEXT)!=0) {
        printf("get_two_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    zero_int = QFALSE;
    for (ilab=0; ilab<oper_num_pert; ilab++) {
        if (oper_pert_labels[ilab]!=PERT_GEOMETRIC &&
            oper_pert_labels[ilab]!=PERT_MAGNETIC) {
            zero_int = QTRUE;
            break;
        }
    }
    if (zero_int==QFALSE) {
        printf("get_two_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
}

void get_linear_rsp_solution(const QInt num_pert,
                             const QInt *num_comps,
                             const QInt *num_freq_sums,
                             const QReal *freq_sums,
                             QcMat *RHS_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void *user_ctx,
#endif
                             QcMat *rsp_param[])
{
#if defined(OPENRSP_C_USER_CONTEXT)
    char *solver_context;
#endif
    static QInt id_rsparam = -1;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    solver_context = (char *)user_ctx;
    if (strcmp(solver_context, SOLVER_CONTEXT)!=0) {
        printf("get_linear_rsp_solution>> invalid context at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    id_rsparam++;
    if (id_rsparam>2) {
        printf("get_linear_rsp_solution>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    ierr = OpenRSPTestReadMat(ALPHA_RSPARAM_AO_HF, id_rsparam, 1, rsp_param);
    if (ierr!=QSUCCESS) {
        printf("get_linear_rsp_solution>> error happened at %s: %s\n",
               FILE_AND_LINE,
               "calling OpenRSPTestReadMat()");
        exit(ierr);
    }
}

@ The atomic-orbital density matrix-based response theory is tested by:
<<OpenRSPDMatTest.h>>=
/*
  <<OpenRSPLicense>>

   This is the header file of unit testing of the AO density matrix-based
   response theory.

   2014-07-31, Bin Gao
   * first version
*/
#if !defined(OPENRSP_DMAT_TEST_H)
#define OPENRSP_DMAT_TEST_H

#include "OpenRSPPertCallback.h"
#include "OpenRSPDMatCallback.h"

extern QErrorCode OpenRSPDMatTest(OpenRSP*,FILE*);

#endif
<<OpenRSPDMatTest.c>>=
/*
  <<OpenRSPLicense>>

   This file tests the AO density matrix-based response theory.

   2014-07-31, Bin Gao
   * first version
*/

#include "OpenRSPDMatTest.h"

#if defined(QCMATRIX_SINGLE_PRECISION)
#define QCREAL_FMT "f"
#else
#define QCREAL_FMT "lf"
#endif

QErrorCode OpenRSPDMatTest(OpenRSP *open_rsp, FILE *fp_log)
{
#include "OpenRSPTestPerturbations.h"
    /* overlap operator */
    QInt overlap_num_pert=2;
    QcPertInt overlap_pert_labels[]={PERT_GEOMETRIC,
                                     PERT_MAGNETIC};
    QInt overlap_pert_orders[]={MAX_ORDER_GEOMETRIC,
                                MAX_ORDER_MAGNETIC};
    /* one-electron Hamiltonian */
    QInt oneham_num_pert=2;
    QcPertInt oneham_pert_labels[]={PERT_GEOMETRIC,
                                    PERT_MAGNETIC};
    QInt oneham_pert_orders[]={MAX_ORDER_GEOMETRIC,
                               MAX_ORDER_MAGNETIC};
    /* external field */
    QInt ext_field_num_pert=3;
    QcPertInt ext_field_pert_labels[]={PERT_GEOMETRIC,
                                       PERT_DIPOLE,
                                       PERT_MAGNETIC};
    QInt ext_field_pert_orders[]={MAX_ORDER_GEOMETRIC,
                                  MAX_ORDER_DIPOLE,
                                  MAX_ORDER_MAGNETIC};
    /* two-electron operator */
    QInt two_oper_num_pert=2;
    QcPertInt two_oper_pert_labels[]={PERT_GEOMETRIC,
                                      PERT_MAGNETIC};
    QInt two_oper_pert_orders[]={MAX_ORDER_GEOMETRIC,
                                 MAX_ORDER_MAGNETIC};
    /* referenced state */
    QcMat *F_unpert[1];
    QcMat *D_unpert[1];
    QcMat *S_unpert[1];
    /* polarizability */
    QInt ALPHA_NUM_PROPS=1;
    QInt ALPHA_LEN_TUPLE[]={2};
    QcPertInt ALPHA_PERT_TUPLE[]={PERT_DIPOLE,PERT_DIPOLE};
    QInt ALPHA_NUM_FREQ_CONFIGS[]={1};
    QReal ALPHA_PERT_FREQS[]={-0.072,0.0,0.072,0.0};
    QInt ALPHA_KN_RULES[]={0};
    /* response functions */
    QInt size_rsp_funs;
    QReal rsp_funs[18];
    QInt ipert,jpert,ival;
    /* error information */
    QErrorCode ierr;

    ///* sets the equation of motion of electrons */
    //ierr = OpenRSPSetElecEOM(open_rsp, ELEC_AO_D_MATRIX);
    //QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetElecEOM");
    //fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPSetElecEOM() passed\n");

    /* sets the context of linear response equation solver */
    ierr = OpenRSPSetLinearRSPSolver(open_rsp,
#if defined(OPENRSP_C_USER_CONTEXT)
                                     (void *)SOLVER_CONTEXT,
#endif
                                     &get_linear_rsp_solution);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetLinearRSPSolver()");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPSetLinearRSPSolver() passed\n");

    /* sets the context of overlap operator */
    ierr = OpenRSPSetOverlap(open_rsp,
                             overlap_num_pert,
                             overlap_pert_labels,
                             overlap_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)OVERLAP_CONTEXT,
#endif
                             &get_overlap_mat,
                             &get_overlap_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetOverlap()");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPSetOverlap() passed\n");

    /* adds one-electron Hamiltonian */
    ierr = OpenRSPAddOneOper(open_rsp,
                             oneham_num_pert,
                             oneham_pert_labels,
                             oneham_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)ONEHAM_CONTEXT,
#endif
                             &get_one_oper_mat,
                             &get_one_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddOneOper(h)");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPAddOneOper(h) passed\n");

    /* adds external field */
    ierr = OpenRSPAddOneOper(open_rsp,
                             ext_field_num_pert,
                             ext_field_pert_labels,
                             ext_field_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)EXT_FIELD_CONTEXT,
#endif
                             &get_one_oper_mat,
                             &get_one_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddOneOper(V)");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPAddOneOper(V) passed\n");

    /* adds two-electron operator */
    ierr = OpenRSPAddTwoOper(open_rsp,
                             two_oper_num_pert,
                             two_oper_pert_labels,
                             two_oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)TWO_OPER_CONTEXT,
#endif
                             &get_two_oper_mat,
                             &get_two_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddTwoOper()");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPAddTwoOper() passed\n");

    /* assembles the context of response theory calculations */
    ierr = OpenRSPAssemble(open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAssemble()");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPAssemble() passed\n");

    /* writes the context of response theory calculations */
    ierr = OpenRSPWrite(open_rsp, fp_log);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPWrite()");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPWrite() passed\n");

    /* sets the unperturbed AO-based Fock matrix */
    F_unpert[0] = (QcMat *)malloc(sizeof(QcMat));
    if (F_unpert[0]==NULL) {
        QErrorExit(FILE_AND_LINE, "allocates memory for Fock matrix");
    }
    ierr = OpenRSPTestReadMat(DMAT_HF_FOCK, 0, 1, F_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPTestReadMat(F)");
    /* sets the unperturbed AO-based density matrix */
    D_unpert[0] = (QcMat *)malloc(sizeof(QcMat));
    if (D_unpert[0]==NULL) {
        QErrorExit(FILE_AND_LINE, "allocates memory for density matrix");
    }
    ierr = OpenRSPTestReadMat(DMAT_HF_DENSITY, 0, 1, D_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPTestReadMat(D)");
    /* sets the unperturbed AO-based overlap integral matrix */
    S_unpert[0] = (QcMat *)malloc(sizeof(QcMat));
    if (S_unpert[0]==NULL) {
        QErrorExit(FILE_AND_LINE, "allocates memory for overlap integral matrix");
    }
    ierr = OpenRSPTestReadMat(DMAT_OVERLAP, 0, 1, S_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPTestReadMat(S)");

    /* gets the polarizability */
    size_rsp_funs = 9;
    ierr = OpenRSPGetRSPFun(open_rsp,
                            F_unpert[0],
                            D_unpert[0],
                            S_unpert[0],
                            ALPHA_NUM_PROPS,
                            ALPHA_LEN_TUPLE,
                            ALPHA_PERT_TUPLE,
                            ALPHA_NUM_FREQ_CONFIGS,
                            ALPHA_PERT_FREQS,
                            ALPHA_KN_RULES,
                            0,
                            1e-8,
                            size_rsp_funs,
                            rsp_funs);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPGetRSPFun()");
    fprintf(fp_log, "OpenRSPDMatTest>> OpenRSPGetRSPFun() passed\n");
    for (ipert=0,ival=0; ipert<3; ipert++) {
        for (jpert=0; jpert<3; jpert++) {
            fprintf(fp_log,
                    " (%"QCREAL_FMT",%"QCREAL_FMT")",
                    rsp_funs[ival], rsp_funs[ival+1]);
            ival += 2;
        }
        fprintf(fp_log, "\n");
    }

    /* cleans */
    ierr = QcMatDestroy(F_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(F)");
    free(F_unpert[0]);
    F_unpert[0] = NULL;
    ierr = QcMatDestroy(D_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(D)");
    free(D_unpert[0]);
    D_unpert[0] = NULL;
    ierr = QcMatDestroy(S_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(S)");
    free(S_unpert[0]);
    S_unpert[0] = NULL;

    return QSUCCESS;
}

<<OpenRSPTest.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of OpenRSP unit testing.

  2014-07-31, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_TEST_H)
#define OPENRSP_TEST_H

#include <string.h>
#include "OpenRSP.h"

#include "OpenRSPTestPerturbations.h"
#include "OpenRSPPertCallback.h"
#include "OpenRSPZeroOperCallback.h"
#include "OpenRSPDMatTest.h"

#if !defined(OPENRSP_TEST_EXECUTABLE)
extern QErrorCode OpenRSPTest(FILE *fp_log);
#endif

#endif

<<OpenRSPTest.c>>=
/*
  <<OpenRSPLicense>>

   This file tests the APIs of OpenRSP library.

   2014-07-31, Bin Gao
   * first version
*/

#include "OpenRSPTest.h"

/* <macrodef name='OPENRSP_TEST_EXECUTABLE'>
     Build test suite as excutables.
   </macrodef> */
#if defined(OPENRSP_TEST_EXECUTABLE)
QErrorCode main()
{
    FILE *fp_log=stdout;  /* file pointer */
#else
QErrorCode OpenRSPTest(FILE *fp_log)
{
#endif
#include "OpenRSPTestPerturbations.h"
    OpenRSP open_rsp;  /* context of response theory calculations */
    QErrorCode ierr;   /* error information */

    /* creates the context of response theory calculations */
    ierr = OpenRSPCreate(&open_rsp, NUM_ATOMS);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPCreate()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPCreate() passed\n");

    /* sets information of all perturbations */
    ierr = OpenRSPSetPerturbations(&open_rsp,
                                   NUM_ALL_PERT,
                                   ALL_PERT_LABELS,
                                   ALL_PERT_MAX_ORDERS,
                                   ALL_PERT_SIZES,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   (void *)PERT_CONTEXT,
#endif
                                   &get_pert_concatenation);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetPerturbations()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPSetPerturbations() passed\n");

    /* adds the nuclear Hamiltonian */
    ierr = OpenRSPAddZeroOper(&open_rsp,
                              NUM_ALL_PERT,
                              ALL_PERT_LABELS,
                              ALL_PERT_MAX_ORDERS,
#if defined(OPENRSP_C_USER_CONTEXT)
                              (void *)ZERO_OPER_CONTEXT,
#endif
                              &get_zero_oper_contrib);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddZeroOper()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPAddZeroOper() passed\n");

    /* tests the density matrix-based response theory */
    ierr = OpenRSPDMatTest(&open_rsp, fp_log);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPDMatTest()");
    fprintf(fp_log, "OpenRSPTest>> density matrix-based response theory passed\n");

    /* destroys the context of response theory calculations */
    ierr = OpenRSPDestroy(&open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPDestroy()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPDestroy() passed\n");

    return QSUCCESS;
}
@

\subsection{Testing Fortran APIs}

<<OpenRSPTest.F90>>=
!! <QcLang='Fortran'>
<<OpenRSPLicenseFortran>>
!!
!! This file tests the Fortran APIs of OpenRSP library.
!!
!! 2014-08-03, Bin Gao
!! * first version

