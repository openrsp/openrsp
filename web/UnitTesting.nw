\section{Unit Testing\index{Unit testing}}
\label{section-unit-testing}

\subsection{Testing C APIs}

We first implement perturbations and its callback function for unit testing:
<<OpenRSPTestPerturbations.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of perturbations.

  2014-07-31, Bin Gao:
  * first version
*/

#include "OpenRSP.h"

#define NUM_ALL_PERT 3
extern const QcPertInt PERT_GEOMETRIC;
extern const QcPertInt PERT_DIPOLE;
extern const QcPertInt PERT_MAGNETIC;
extern const QInt MAX_ORDER_GEOMETRIC;
extern const QInt MAX_ORDER_DIPOLE;
extern const QInt MAX_ORDER_MAGNETIC;
extern const QcPertInt ALL_PERT_LABELS[NUM_ALL_PERT];
extern const QInt ALL_PERT_MAX_ORDERS[NUM_ALL_PERT];
extern const QInt ALL_PERT_SIZES[15];
extern const QInt NUM_ATOMS;
<<OpenRSPTestPerturbations.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPTestPerturbations.h"

const QcPertInt PERT_GEOMETRIC = 1;
const QcPertInt PERT_DIPOLE = 2;
const QcPertInt PERT_MAGNETIC = 5;
const QInt MAX_ORDER_GEOMETRIC = 7;
const QInt MAX_ORDER_DIPOLE = 1;
const QInt MAX_ORDER_MAGNETIC = 7;
/* labels of all perturbations */
const QcPertInt ALL_PERT_LABELS[]={PERT_GEOMETRIC,
                                   PERT_DIPOLE,
                                   PERT_MAGNETIC};
/* allowed maximal orders of all perturbations */
const QInt ALL_PERT_MAX_ORDERS[]={MAX_ORDER_GEOMETRIC,
                                  MAX_ORDER_DIPOLE,
                                  MAX_ORDER_MAGNETIC};
/* sizes of all perturbations up to their maximal orders */
const QInt ALL_PERT_SIZES[]={
    12,78,364,1365,4368,12376,31824,  /* geometric derivatives (4 atoms) */
    3,                                /* electric dipole */
    3,6,10,15,21,28,36};              /* magnetic derivatives */
const QInt NUM_ATOMS=4;
@ Here we have used three different perturbation labels for geometric, dipole
length and magnetic perturbations.
<<OpenRSPPertCallback.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of perturbations' callback function.

  2014-07-31, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_PERT_CALLBACK_H)
#define OPENRSP_PERT_CALLBACK_H

#include "OpenRSP.h"

#if defined(OPENRSP_C_USER_CONTEXT)
#define PERT_CONTEXT "NRNZGEO"
#endif

extern void get_pert_concatenation(const QInt,
                                   const QcPertInt,
                                   const QInt,
                                   const QInt,
                                   const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   void*,
#endif
                                   QInt*);

#endif
<<OpenRSPPertCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPPertCallback.h"

void get_pert_concatenation(const QInt pert_label,
                            const QcPertInt first_cat_comp,
                            const QInt num_cat_comps,
                            const QInt num_sub_tuples,
                            const QInt *len_sub_tuples,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void *user_ctx,
#endif
                            QInt *rank_sub_comps)
{
/*FIXME: to implement*/
}
@

The following header and C files implement the callback function for nuclear
Hamiltonian:
<<OpenRSPNucHamiltonCallback.h>>=
/*
  <<OpenRSPLicense>>

  This header file contains callback function for nuclear Hamiltonian.

  2015-10-16, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_NUC_HAMILTON_CALLBACK_H)
#define OPENRSP_NUC_HAMILTON_CALLBACK_H

#include "OpenRSP.h"

#if defined(OPENRSP_C_USER_CONTEXT)
#define NUC_HAMILTON_CONTEXT "NUC_HAMILTON"
#endif

extern void get_nuc_contrib(const QInt,
                            const QcPertInt*,
                            const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QReal*);

#endif
<<OpenRSPNucHamiltonCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPNucHamiltonCallback.h"

void get_nuc_contrib(const QInt nuc_num_pert,
                     const QcPertInt *nuc_pert_labels,
                     const QInt *nuc_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt size_pert,
                     QReal *val_nuc)
{
/*FIXME: to implement*/
}
@

We next implement callback functions for AO-based response theory calculations:
<<OpenRSPDensAOCallback.h>>=
/*
  <<OpenRSPLicense>>

  This header file contains callback functions for AO-based response theory
  calculations.

  2015-10-16, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_DENS_AO_CALLBACK_H)
#define OPENRSP_DENS_AO_CALLBACK_H

#include "OpenRSP.h"
#include "OpenRSPTestData.h"

#if defined(OPENRSP_C_USER_CONTEXT)
#define OVERLAP_CONTEXT "OVERLAP"
#define ONEHAM_CONTEXT "ONEHAM"
#define EXT_FIELD_CONTEXT "EXT_FIELD"
#define TWO_OPER_CONTEXT "NONLAO"
#define SOLVER_CONTEXT "SOLVER"
#endif

extern void get_overlap_mat(const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QcMat*[]);
extern void get_overlap_exp(const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            const QcPertInt*,
                            const QInt*,
                            const QInt,
                            QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                            void*,
#endif
                            const QInt,
                            QReal*);
extern void get_one_oper_mat(const QInt,
                             const QcPertInt*,
                             const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QcMat*[]);
extern void get_one_oper_exp(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QReal*);
extern void get_two_oper_mat(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QcMat*[]);
extern void get_two_oper_exp(const QInt,
                             const QcPertInt*,
                             const QInt*,
                             const QInt,
                             const QInt*,
                             QcMat*[],
                             const QInt*,
                             QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void*,
#endif
                             const QInt,
                             QReal*);
extern void get_linear_rsp_solution(const QInt,
                                    const QReal*,
                                    const QInt,
                                    QcMat*[],
#if defined(OPENRSP_C_USER_CONTEXT)
                                    void*,
#endif
                                    QcMat*[]);

#endif
@ Here we mimic callback functions by reading different AO-based matrices from
files [[*.dat]]. These matrices were calculated from Dalton program, and saved
in the directory [[tests]]. During building, the following CMake file will
generated list of filenames containing these AO-based matrices:
<<OpenRSPTestData.cmake>>=
# Generated by notangle -ROpenRSPTestData.cmake web/UnitTesting.nw > cmake/OpenRSPTestData.cmake
include_directories(${PROJECT_BINARY_DIR})
# atomic-orbital (AO) density matrix-based response theory
set(OPENRSP_TEST_DATA ${PROJECT_BINARY_DIR}/OpenRSPTestData.h)
file(WRITE ${OPENRSP_TEST_DATA} "#if !defined(OPENRSP_TEST_DATA_H)\n")
file(APPEND ${OPENRSP_TEST_DATA} "#define OPENRSP_TEST_DATA_H\n\n")
file(APPEND ${OPENRSP_TEST_DATA} "#include \"qcmatrix.h\"\n\n")
# function of reading matrices from a dat file
file(APPEND ${OPENRSP_TEST_DATA} "extern QErrorCode OpenRSPTestReadMat(const char*,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     const QInt,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     const QInt,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     QcMat*[]);\n\n")
# function of zeroing matrices
file(APPEND ${OPENRSP_TEST_DATA} "extern QErrorCode OpenRSPTestZeroMat(const QInt,\n")
file(APPEND ${OPENRSP_TEST_DATA} "                                     QcMat*[]);\n\n")
# unperturbed AO-based Fock matrix
get_filename_component(FOCK_AO_HF
                       ${LIB_OPENRSP_PATH}/tests/FockAOHF.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define FOCK_AO_HF \"${FOCK_AO_HF}\"\n")
# unperturbed AO-based density matrix
get_filename_component(DENS_AO_HF
                       ${LIB_OPENRSP_PATH}/tests/DensAOHF.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define DENS_AO_HF \"${DENS_AO_HF}\"\n")
# unperturbed AO-based overlap integral matrix
get_filename_component(OVERLAP_AO
                       ${LIB_OPENRSP_PATH}/tests/OverlapAO.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define OVERLAP_AO \"${OVERLAP_AO}\"\n")
# unperturbed AO-based dipole length integral matrices
get_filename_component(DIPLEN_AO
                       ${LIB_OPENRSP_PATH}/tests/DipLenAO.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define DIPLEN_AO \"${DIPLEN_AO}\"\n")
# two-electron integrals contracted with perturbed AO-based density matrices
# for solving polarizability at frequency as 0.072
get_filename_component(ALPHA_GMAT_AO_HF
                       ${LIB_OPENRSP_PATH}/tests/AlphaGMatAOHF.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define ALPHA_GMAT_AO_HF \"${ALPHA_GMAT_AO_HF}\"\n")
# response parameters for solving polarizability at frequency as 0.072
get_filename_component(ALPHA_RSPARAM_AO_HF
                       ${LIB_OPENRSP_PATH}/tests/AlphaRSParamAOHF.dat
                       ABSOLUTE)
file(APPEND
     ${OPENRSP_TEST_DATA}
     "#define ALPHA_RSPARAM_AO_HF \"${ALPHA_RSPARAM_AO_HF}\"\n")
file(APPEND ${OPENRSP_TEST_DATA} "\n#endif\n")
@ The following file will read a [[tests/*.dat]] file and put the data into
matrices:
<<OpenRSPTestData.c>>=
/*
  <<OpenRSPLicense>>
*/

#if defined(QCMATRIX_SINGLE_PRECISION)
#define QCREAL_FMT "f"
#else
#define QCREAL_FMT "lf"
#endif

#include "OpenRSPTestData.h"

/* <function name='OpenRSPTestReadMat'
             attr='private'
             author='Bin Gao'
             date='2015-10-18'>
     Reads a dat file and puts the data into matrices
     <param name='file_mat' direction='in'>
       Name of the dat file
     </param>
     <param name='num_skip_mat' direction='in'>
       Number of the first few matrices to skip
     </param>
     <param name='num_read_mat' direction='in'>
       Number of matrices to read
     </param>
     <param name='mat_read' direction='inout'>
       Matrices read
     </param>
     <return>Error information</return>
   </function> */
QErrorCode OpenRSPTestReadMat(const char *file_mat,
                              const QInt num_skip_mat,
                              const QInt num_read_mat,
                              QcMat *mat_read[])
{
    FILE *fp_dat;       /* file pointer */
    QInt dat_num_read;  /* number of arguments read from the dat file */
    QInt dat_num_mat;   /* number of matrices in the dat file */
    QInt dat_num_row;   /* number of rows of matrices */
    QInt dat_num_col;   /* number of columns of matrices */
    QInt dat_num_val;   /* number of values of matrices */
    QReal *dat_values;  /* values of matrices */
    QInt imat;          /* incremental recorder over matrices */
    QInt ival;          /* incremental recorder over values */
    QBool assembled;    /* matrix assembled or not */
    QErrorCode ierr;    /* error information */
    /* parameters for setting matrices */
    const QInt NUM_BLOCKS=1;
#if defined(ZERO_BASED_NUMBERING)
    const QInt IDX_BLOCK_ROW[]={0};
    const QInt IDX_BLOCK_COL[]={0};
    const QInt IDX_FIRST_ROW=0;
    const QInt IDX_FIRST_COL=0;
#else
    const QInt IDX_BLOCK_ROW[]={1};
    const QInt IDX_BLOCK_COL[]={1};
    const QInt IDX_FIRST_ROW=1;
    const QInt IDX_FIRST_COL=1;
#endif
    QcDataType DATA_TYPE[1]={QREALMAT};
    fp_dat = fopen(file_mat, "r");
    if (fp_dat==NULL) {
        printf("OpenRSPTestReadMat>> file: %s\n", file_mat);
        QErrorExit(FILE_AND_LINE, "open the dat file");
    }
    dat_num_read = fscanf(fp_dat,
                          "%"QINT_FMT" %"QINT_FMT" %"QINT_FMT"",
                          &dat_num_mat, &dat_num_row, &dat_num_col);
    if (dat_num_read!=3) {
        printf("OpenRSPTestReadMat>> number of arguments read %"QINT_FMT"\n",
               dat_num_read);
        QErrorExit(FILE_AND_LINE, "read information of data");
    }
    /* checks the number of matrices to read */
    if (num_skip_mat+num_read_mat>dat_num_mat) {
        printf("OpenRSPTestReadMat>> number of skipping matrices %"QINT_FMT"\n",
               num_skip_mat);
        printf("OpenRSPTestReadMat>> number of reading matrices %"QINT_FMT"\n",
               num_read_mat);
        printf("OpenRSPTestReadMat>> number of matrices on the file %"QINT_FMT"\n",
               dat_num_mat);
        QErrorExit(FILE_AND_LINE, "not enough matrices on the file");
    }
    dat_num_val = dat_num_row*dat_num_col;
    dat_values = (QReal *)malloc(dat_num_val*sizeof(QReal));
    if (dat_values==NULL) {
        printf("OpenRSPTestReadMat>> number of values %"QINT_FMT"\n",
               dat_num_val);
        QErrorExit(FILE_AND_LINE, "allocates memory for values");
    }
    /* skips the first few lines, including the '\n' of the first line */
    for (imat=0; imat<=num_skip_mat; imat++) {
        /*fscanf(fp_dat, "%*[^\n]\n", NULL);*/
        do {
            dat_num_read = fgetc(fp_dat);
        } while (dat_num_read!='\n');
    }
    for (imat=0; imat<num_read_mat; imat++) {
        for (ival=0; ival<dat_num_val; ival++) {
            if (fscanf(fp_dat, "%"QCREAL_FMT"", &dat_values[ival])!=1) {
                printf("OpenRSPTestReadMat>> %"QINT_FMT"-th element\n", ival);
                QErrorExit(FILE_AND_LINE, "read values");
            }
        }
        /* checks if the matrix is assembled or not */
        ierr = QcMatIsAssembled(mat_read[imat], &assembled);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatIsAssembled()");
        if (assembled==QFALSE) {
            ierr = QcMatBlockCreate(mat_read[imat], NUM_BLOCKS);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate()");
            ierr = QcMatSetDataType(mat_read[imat],
                                    NUM_BLOCKS,
                                    IDX_BLOCK_ROW,
                                    IDX_BLOCK_COL,
                                    DATA_TYPE);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType()");
            ierr = QcMatSetDimMat(mat_read[imat], dat_num_row, dat_num_col);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat()");
            ierr = QcMatAssemble(mat_read[imat]);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble()");
        }
        /* saves the values into the matrix */
        ierr = QcMatSetValues(mat_read[imat],
                              IDX_BLOCK_ROW[0],
                              IDX_BLOCK_COL[0],
                              IDX_FIRST_ROW,
                              dat_num_row,
                              IDX_FIRST_COL,
                              dat_num_col,
                              dat_values,
                              NULL);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetValues()");
    }
    free(dat_values);
    dat_values = NULL;
    fclose(fp_dat);
    return QSUCCESS;
}
@

%In the above code, we have used [[fscanf(fp_dat, "%*[^\n]\n", NULL);]] to
%skip the first few lines of the [[dat]] file. This is learnt from
%\href{http://stackoverflow.com/questions/2799612/how-to-skip-the-first-line-when-fscanning-a-txt-file}{How to skip the first line when fscanning a .txt file?}
%where
%\begin{quotation}
%the format string represent a line containing any character including spaces.
%The [[*]] in the format string and the [[NULL]] pointer mean we are not
%interested in saving the line, but just in incrementing the file position.
%\end{quotation}
%
%\begin{quotation}
%[[%]] is the character which each scanf format string starts with;
%[[*]] indicates to not put the found pattern anywhere (typically you save
%pattern found into parameters after the format string, in this case the
%parameter is [[NULL]]);
%[[[^\n]]] means any character except newline;
%[[\n]] means newline;
%
%So the [[[^\n]\n]] means a full text line ending with newline.
%\end{quotation}

The following function will zero out a few matrices:
<<OpenRSPTestData.c>>=
/* <function name='OpenRSPTestZeroMat'
             attr='private'
             author='Bin Gao'
             date='2015-10-18'>
     Zero out a few matrices
     <param name='num_mat' direction='in'>
       Number of matrices to be zeroed out
     </param>
     <param name='mat_zero' direction='inout'>
       Matrices to be zeroed out
     </param>
     <return>Error information</return>
   </function> */
QErrorCode OpenRSPTestZeroMat(const QInt num_mat, QcMat *mat_zero[])
{
    QInt imat;          /* incremental recorder over matrices */
    QBool assembled;    /* matrix assembled or not */
    QErrorCode ierr;    /* error information */
    /* parameters for setting matrices */
    const QInt NUM_BLOCKS=1;
#if defined(ZERO_BASED_NUMBERING)
    const QInt IDX_BLOCK_ROW[]={0};
    const QInt IDX_BLOCK_COL[]={0};
#else
    const QInt IDX_BLOCK_ROW[]={1};
    const QInt IDX_BLOCK_COL[]={1};
#endif
    QcDataType DATA_TYPE[1]={QREALMAT};
    const QInt DAT_NUM_ROW=32;
    const QInt DAT_NUM_COL=32;
    for (imat=0; imat<num_mat; imat++) {
        /* checks if the matrix is assembled or not */
        ierr = QcMatIsAssembled(mat_zero[imat], &assembled);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatIsAssembled()");
        if (assembled==QFALSE) {
            ierr = QcMatBlockCreate(mat_zero[imat], NUM_BLOCKS);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatBlockCreate()");
            ierr = QcMatSetSymType(mat_zero[imat], QSYMMAT);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetSymType()");
            ierr = QcMatSetDataType(mat_zero[imat],
                                    NUM_BLOCKS,
                                    IDX_BLOCK_ROW,
                                    IDX_BLOCK_COL,
                                    DATA_TYPE);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDataType()");
            ierr = QcMatSetDimMat(mat_zero[imat], DAT_NUM_ROW, DAT_NUM_COL);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatSetDimMat()");
            ierr = QcMatAssemble(mat_zero[imat]);
            QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatAssemble()");
        }
        /* zeroes out the matrix */
        ierr = QcMatZeroEntries(mat_zero[imat]);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatZeroEntries()");
    }
    return QSUCCESS;
}

@ By using the above functions to read matrices for [[dat]] files and zero
matrices, we can implement the following file callback functions for AO-based
response theory calculations:
<<OpenRSPDensAOCallback.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSPDensAOCallback.h"

void get_overlap_mat(const QInt bra_num_pert,
                     const QcPertInt *bra_pert_labels,
                     const QInt *bra_pert_orders,
                     const QInt ket_num_pert,
                     const QcPertInt *ket_pert_labels,
                     const QInt *ket_pert_orders,
                     const QInt oper_num_pert,
                     const QcPertInt *oper_pert_labels,
                     const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt num_int,
                     QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context;
#endif
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    overlap_context = (char *)user_ctx;
    if (strcmp(overlap_context, OVERLAP_CONTEXT)!=0) {
        printf("get_overlap_mat>> incorrect operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    /* unperturbed AO-based overlap integral matrix */
    if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==0) {
        ierr = OpenRSPTestReadMat(OVERLAP_AO, 0, 1, val_int);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling OpenRSPTestReadMat()");
            exit(ierr);
        }
    }
    else if (oper_num_pert==1 && bra_num_pert==0 && ket_num_pert==0) {
        if (oper_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero matrices */
        else if (oper_pert_labels[0]==PERT_DIPOLE) {
            ierr = OpenRSPTestZeroMat(num_int, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestZeroMat()");
                exit(ierr);
            }
        }
        else if (oper_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_mat>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==1 && ket_num_pert==0) {
        if (bra_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero matrices */
        else if (bra_pert_labels[0]==PERT_DIPOLE) {
            ierr = OpenRSPTestZeroMat(num_int, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestZeroMat()");
                exit(ierr);
            }
        }
        else if (bra_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_mat>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==1) {
        if (ket_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero matrices */
        else if (ket_pert_labels[0]==PERT_DIPOLE) {
            ierr = OpenRSPTestZeroMat(num_int, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestZeroMat()");
                exit(ierr);
            }
        }
        else if (ket_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_mat>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
        printf("get_overlap_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
}

void get_overlap_exp(const QInt bra_num_pert,
                     const QcPertInt *bra_pert_labels,
                     const QInt *bra_pert_orders,
                     const QInt ket_num_pert,
                     const QcPertInt *ket_pert_labels,
                     const QInt *ket_pert_orders,
                     const QInt oper_num_pert,
                     const QcPertInt *oper_pert_labels,
                     const QInt *oper_pert_orders,
                     const QInt num_dens,
                     QcMat *ao_dens[],
#if defined(OPENRSP_C_USER_CONTEXT)
                     void *user_ctx,
#endif
                     const QInt num_exp,
                     QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *overlap_context;
#endif
    QcMat *val_int[1];
    QInt idens;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    overlap_context = (char *)user_ctx;
    if (strcmp(overlap_context, OVERLAP_CONTEXT)!=0) {
        printf("get_overlap_mat>> incorrect operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    /* unperturbed AO-based overlap integral matrix */
    if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==0) {
        val_int[0] = (QcMat *)malloc(sizeof(QcMat));
        if (val_int[0]==NULL) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "allocats memory for matrix");
            exit(QFAILURE);
        }
        ierr = QcMatCreate(val_int[0]);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatCreate()");
            exit(ierr);
        }
        ierr = OpenRSPTestReadMat(OVERLAP_AO, 0, 1, val_int);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling OpenRSPTestReadMat()");
            exit(ierr);
        }
        for (idens=0; idens<num_dens; idens++) {
            ierr = QcMatGetMatProdTrace(val_int[0],
                                        ao_dens[idens],
                                        MAT_NO_OPERATION,
                                        1,
                                        &val_exp[2*idens]);
            if (ierr!=QSUCCESS) {
                printf("get_overlap_exp>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling QcMatGetMatProdTrace");
                exit(ierr);
            }
        }
        ierr = QcMatDestroy(val_int[0]);
        if (ierr!=QSUCCESS) {
            printf("get_overlap_exp>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling QcMatDestroy()");
            exit(ierr);
        }
        free(val_int[0]);
        val_int[0] = NULL;
    }
    else if (oper_num_pert==1 && bra_num_pert==0 && ket_num_pert==0) {
        if (oper_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero matrices */
        else if (oper_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else if (oper_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==1 && ket_num_pert==0) {
        if (bra_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero matrices */
        else if (bra_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else if (bra_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==0 && ket_num_pert==1) {
        if (ket_pert_labels[0]==PERT_GEOMETRIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        /* zero matrices */
        else if (ket_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else if (ket_pert_labels[0]==PERT_MAGNETIC) {
            printf("get_overlap_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (oper_num_pert==0 && bra_num_pert==1 && ket_num_pert==1) {
        /* zero matrices */
        if (bra_pert_labels[0]==PERT_DIPOLE || ket_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else {
            printf("get_overlap_exp>> unknown perturbations at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
         printf("get_overlap_exp>> not implemented at %s\n",
                FILE_AND_LINE);
         exit(QFAILURE);
    }
}

void get_one_oper_mat(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_int,
                      QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *one_oper_context;
#endif
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    one_oper_context = (char *)user_ctx;
    if (strcmp(one_oper_context, ONEHAM_CONTEXT)==0) {
        /* zero matrices */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            ierr = OpenRSPTestZeroMat(num_int, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_one_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestZeroMat()");
                exit(ierr);
            }
        }
        else {
            printf("get_one_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (strcmp(one_oper_context, EXT_FIELD_CONTEXT)==0) {
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            /* unperturbed AO-based dipole length integral matrices */
            if (oper_pert_orders[0]==1) {
                ierr = OpenRSPTestReadMat(DIPLEN_AO, 0, 3, val_int);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling OpenRSPTestReadMat()");
                    exit(ierr);
                }
            }
            /* zero matrices */
            else {
                ierr = OpenRSPTestZeroMat(num_int, val_int);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_mat>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling OpenRSPTestZeroMat()");
                    exit(ierr);
                }
            }
        }
        else {
            printf("get_one_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
        printf("get_one_oper_mat>> unknown one-electron operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#else
    if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        /* unperturbed AO-based dipole length integral matrices */
        if (oper_pert_orders[0]==1) {
            ierr = OpenRSPTestReadMat(DIPLEN_AO, 0, 3, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_one_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestReadMat()");
                exit(ierr);
            }
        }
        /* zero matrices */
        else {
            ierr = OpenRSPTestZeroMat(num_int, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_one_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestZeroMat()");
                exit(ierr);
            }
        }
    }
    else {
        printf("get_one_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_one_oper_exp(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt num_dmat,
                      QcMat *dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_exp,
                      QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *one_oper_context;
#endif
    QcMat *val_int[1];
    QInt imat;
    QInt offset_exp;
    QInt idens;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    one_oper_context = (char *)user_ctx;
    if (strcmp(one_oper_context, ONEHAM_CONTEXT)==0) {
        /* zero matrices */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
        else {
            printf("get_one_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else if (strcmp(one_oper_context, EXT_FIELD_CONTEXT)==0) {
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            /* unperturbed AO-based dipole length integral matrices */
            if (oper_pert_orders[0]==1) {
                val_int[0] = (QcMat *)malloc(sizeof(QcMat));
                if (val_int[0]==NULL) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "allocats memory for matrix");
                    exit(QFAILURE);
                }
                offset_exp = 0;
                for (imat=0; imat<3; imat++) {
                    ierr = QcMatCreate(val_int[0]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatCreate()");
                        exit(ierr);
                    }
                    ierr = OpenRSPTestReadMat(DIPLEN_AO, imat, 1, val_int);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling OpenRSPTestReadMat()");
                        exit(ierr);
                    }
                    for (idens=0; idens<num_dmat; idens++) {
                        ierr = QcMatGetMatProdTrace(val_int[0],
                                                    dens_mat[idens],
                                                    MAT_NO_OPERATION,
                                                    1,
                                                    &val_exp[offset_exp+2*idens]);
                        if (ierr!=QSUCCESS) {
                            printf("get_one_oper_exp>> error happened at %s: %s\n",
                                   FILE_AND_LINE,
                                   "calling QcMatGetMatProdTrace()");
                            exit(ierr);
                        }
                    }
                    ierr = QcMatDestroy(val_int[0]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatDestroy()");
                        exit(ierr);
                    }
                    offset_exp += 2*num_dmat;
                }
                free(val_int[0]);
                val_int[0] = NULL;
            }
            /* zero matrices */
            else {
                for (idens=0; idens<2*num_exp; idens++) {
                    val_exp[idens] = 0;
                }
            }
        }
        else {
            printf("get_one_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
    else {
        printf("get_one_oper_exp>> unknown one-electron operator at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#else
    if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        /* unperturbed AO-based dipole length integral matrices */
        if (oper_pert_orders[0]==1) {
            offset_exp = 0;
            for (imat=0; imat<3; imat++) {
                ierr = QcMatCreate(&val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatCreate()");
                    exit(ierr);
                }
                ierr = OpenRSPTestReadMat(DIPLEN_AO, imat, 1, val_int);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling OpenRSPTestReadMat()");
                    exit(ierr);
                }
                for (idens=0; idens<num_dmat; idens++) {
                    ierr = QcMatGetMatProdTrace(&val_int[0],
                                                dens_mat[idens],
                                                MAT_NO_OPERATION,
                                                1,
                                                &val_exp[offset_exp+2*idens]);
                    if (ierr!=QSUCCESS) {
                        printf("get_one_oper_exp>> error happened at %s: %s\n",
                               FILE_AND_LINE,
                               "calling QcMatGetMatProdTrace()");
                        exit(ierr);
                    }
                }
                ierr = QcMatDestroy(val_int[0]);
                if (ierr!=QSUCCESS) {
                    printf("get_one_oper_exp>> error happened at %s: %s\n",
                           FILE_AND_LINE,
                           "calling QcMatDestroy()");
                    exit(ierr);
                }
                offset_exp += 2*num_dmat;
            }
        }
        /* zero matrices */
        else {
            for (idens=0; idens<2*num_exp; idens++) {
                val_exp[idens] = 0;
            }
        }
    else {
        printf("get_one_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_two_oper_mat(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt num_dmat,
                      QcMat *dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_int,
                      QcMat *val_int[])
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *two_oper_context;
#endif
    QErrorCode ierr;
    static QInt id_gmat = -1;
#if defined(OPENRSP_C_USER_CONTEXT)
    two_oper_context = (char *)user_ctx;
    if (strcmp(two_oper_context, TWO_OPER_CONTEXT)!=0) {
        printf("get_two_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    else {
	/* two-electron integrals contracted with perturbed AO-based density
           matrices for solving polarizability at frequency as 0.072 */
        if (oper_num_pert==0) {
            id_gmat++;
            if (id_gmat>5) {
                printf("get_two_oper_mat>> not implemented at %s\n",
                       FILE_AND_LINE);
                exit(QFAILURE);
            }
            ierr = OpenRSPTestReadMat(ALPHA_GMAT_AO_HF, id_gmat, 1, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestReadMat()");
                exit(ierr);
            }
        }
        /* zero matrices */
        else if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            ierr = OpenRSPTestZeroMat(num_int, val_int);
            if (ierr!=QSUCCESS) {
                printf("get_two_oper_mat>> error happened at %s: %s\n",
                       FILE_AND_LINE,
                       "calling OpenRSPTestZeroMat()");
                exit(ierr);
            }
        }
        else {
            printf("get_two_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
#else
    /* two-electron integrals contracted with perturbed AO-based density
       matrices for solving polarizability at frequency as 0.072 */
    if (oper_num_pert==0) {
        id_gmat++;
        if (id_gmat>5) {
            printf("get_two_oper_mat>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
        ierr = OpenRSPTestReadMat(ALPHA_GMAT_AO_HF, id_gmat, 1, val_int);
        if (ierr!=QSUCCESS) {
            printf("get_two_oper_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling OpenRSPTestReadMat()");
            exit(ierr);
        }
    }
    /* zero matrices */
    else if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        ierr = OpenRSPTestZeroMat(num_int, val_int);
        if (ierr!=QSUCCESS) {
            printf("get_two_oper_mat>> error happened at %s: %s\n",
                   FILE_AND_LINE,
                   "calling OpenRSPTestZeroMat()");
            exit(ierr);
        }
    }
    else {
        printf("get_two_oper_mat>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_two_oper_exp(const QInt oper_num_pert,
                      const QcPertInt *oper_pert_labels,
                      const QInt *oper_pert_orders,
                      const QInt dmat_len_tuple,
                      const QInt *num_LHS_dmat,
                      QcMat *LHS_dens_mat[],
                      const QInt *num_RHS_dmat,
                      QcMat *RHS_dens_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                      void *user_ctx,
#endif
                      const QInt num_exp,
                      QReal *val_exp)
{
#include "OpenRSPTestPerturbations.h"
#if defined(OPENRSP_C_USER_CONTEXT)
    char *two_oper_context;
#endif
    QInt ival;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    two_oper_context = (char *)user_ctx;
    if (strcmp(two_oper_context, TWO_OPER_CONTEXT)!=0) {
        printf("get_two_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    else {
        /* zero matrices */
        if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
            for (ival=0; ival<2*num_exp; ival++) {
                val_exp[ival] = 0;
            }
        }
        else {
            printf("get_two_oper_exp>> not implemented at %s\n",
                   FILE_AND_LINE);
            exit(QFAILURE);
        }
    }
#else
    /* zero matrices */
    if (oper_num_pert==1 && oper_pert_labels[0]==PERT_DIPOLE) {
        for (ival=0; ival<2*num_exp; ival++) {
            val_exp[ival] = 0;
        }
    }
    else {
        printf("get_two_oper_exp>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
}

void get_linear_rsp_solution(const QInt size_pert,
                             const QReal *freq_sums,
                             const QInt num_freq_sums,
                             QcMat *RHS_mat[],
#if defined(OPENRSP_C_USER_CONTEXT)
                             void *user_ctx,
#endif
                             QcMat *rsp_param[])
{
#if defined(OPENRSP_C_USER_CONTEXT)
    char *solver_context;
#endif
    static QInt id_rsparam = -1;
    QErrorCode ierr;
#if defined(OPENRSP_C_USER_CONTEXT)
    solver_context = (char *)user_ctx;
    if (strcmp(solver_context, SOLVER_CONTEXT)!=0) {
        printf("get_linear_rsp_solution>> invalid context at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
#endif
    id_rsparam++;
    if (id_rsparam>2) {
        printf("get_linear_rsp_solution>> not implemented at %s\n",
               FILE_AND_LINE);
        exit(QFAILURE);
    }
    ierr = OpenRSPTestReadMat(ALPHA_RSPARAM_AO_HF, id_rsparam, 1, rsp_param);
    if (ierr!=QSUCCESS) {
        printf("get_linear_rsp_solution>> error happened at %s: %s\n",
               FILE_AND_LINE,
               "calling OpenRSPTestReadMat()");
        exit(ierr);
    }
}

@ The atomic-orbital density matrix-based response theory is tested by:
<<OpenRSPDensAOTest.h>>=
/*
  <<OpenRSPLicense>>

   This is the header file of unit testing of the AO density matrix-based
   response theory.

   2014-07-31, Bin Gao
   * first version
*/
#if !defined(OPENRSP_DENS_AO_TEST_H)
#define OPENRSP_DENS_AO_TEST_H

#include "OpenRSPPertCallback.h"
#include "OpenRSPDensAOCallback.h"

extern QErrorCode OpenRSPDensAOTest(OpenRSP*,FILE*);

#endif
<<OpenRSPDensAOTest.c>>=
/*
  <<OpenRSPLicense>>

   This file tests the AO density matrix-based response theory.

   2014-07-31, Bin Gao
   * first version
*/

#include "OpenRSPDensAOTest.h"

#if defined(QCMATRIX_SINGLE_PRECISION)
#define QCREAL_FMT "f"
#else
#define QCREAL_FMT "lf"
#endif

QErrorCode OpenRSPDensAOTest(OpenRSP *open_rsp, FILE *fp_log)
{
#include "OpenRSPTestPerturbations.h"
    /* overlap operator */
    QInt overlap_num_pert=2;
    QcPertInt overlap_pert_labels[]={PERT_GEOMETRIC,
                                     PERT_MAGNETIC};
    QInt overlap_pert_orders[]={MAX_ORDER_GEOMETRIC,
                                MAX_ORDER_MAGNETIC};
    /* one-electron Hamiltonian */
    QInt oneham_num_pert=2;
    QcPertInt oneham_pert_labels[]={PERT_GEOMETRIC,
                                    PERT_MAGNETIC};
    QInt oneham_pert_orders[]={MAX_ORDER_GEOMETRIC,
                               MAX_ORDER_MAGNETIC};
    /* external field */
    QInt ext_field_num_pert=3;
    QcPertInt ext_field_pert_labels[]={PERT_GEOMETRIC,
                                       PERT_DIPOLE,
                                       PERT_MAGNETIC};
    QInt ext_field_pert_orders[]={MAX_ORDER_GEOMETRIC,
                                  MAX_ORDER_DIPOLE,
                                  MAX_ORDER_MAGNETIC};
    /* two-electron operator */
    QInt two_oper_num_pert=2;
    QcPertInt two_oper_pert_labels[]={PERT_GEOMETRIC,
                                      PERT_MAGNETIC};
    QInt two_oper_pert_orders[]={MAX_ORDER_GEOMETRIC,
                                 MAX_ORDER_MAGNETIC};
    /* referenced state */
    QcMat *F_unpert[1];
    QcMat *D_unpert[1];
    QcMat *S_unpert[1];
    /* polarizability */
    QInt ALPHA_NUM_PROPS=1;
    QInt ALPHA_LEN_TUPLE[]={2};
    QcPertInt ALPHA_PERT_TUPLE[]={PERT_DIPOLE,PERT_DIPOLE};
    QInt ALPHA_NUM_FREQ_CONFIGS[]={1};
    QReal ALPHA_PERT_FREQS[]={-0.072,0.0,0.072,0.0};
    QInt ALPHA_KN_RULES[]={0};
    /* response functions */
    QInt size_rsp_funs;
    QReal rsp_funs[18];
    QInt ipert,jpert,ival;
    /* error information */
    QErrorCode ierr;

    ///* sets the equation of motion of electrons */
    //ierr = OpenRSPSetElecEOM(open_rsp, ELEC_AO_D_MATRIX);
    //QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetElecEOM");
    //fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPSetElecEOM() passed\n");

    /* sets the context of linear response equation solver */
    ierr = OpenRSPSetLinearRSPSolver(open_rsp,
#if defined(OPENRSP_C_USER_CONTEXT)
                                     (void *)SOLVER_CONTEXT,
#endif
                                     &get_linear_rsp_solution);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetLinearRSPSolver()");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPSetLinearRSPSolver() passed\n");

    /* sets the context of overlap operator */
    ierr = OpenRSPSetOverlap(open_rsp,
                             overlap_num_pert,
                             overlap_pert_labels,
                             overlap_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)OVERLAP_CONTEXT,
#endif
                             &get_overlap_mat,
                             &get_overlap_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetOverlap()");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPSetOverlap() passed\n");

    /* adds one-electron Hamiltonian */
    ierr = OpenRSPAddOneOper(open_rsp,
                             oneham_num_pert,
                             oneham_pert_labels,
                             oneham_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)ONEHAM_CONTEXT,
#endif
                             &get_one_oper_mat,
                             &get_one_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddOneOper(h)");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPAddOneOper(h) passed\n");

    /* adds external field */
    ierr = OpenRSPAddOneOper(open_rsp,
                             ext_field_num_pert,
                             ext_field_pert_labels,
                             ext_field_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)EXT_FIELD_CONTEXT,
#endif
                             &get_one_oper_mat,
                             &get_one_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddOneOper(V)");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPAddOneOper(V) passed\n");

    /* adds two-electron operator */
    ierr = OpenRSPAddTwoOper(open_rsp,
                             two_oper_num_pert,
                             two_oper_pert_labels,
                             two_oper_pert_orders,
#if defined(OPENRSP_C_USER_CONTEXT)
                             (void *)TWO_OPER_CONTEXT,
#endif
                             &get_two_oper_mat,
                             &get_two_oper_exp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAddTwoOper()");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPAddTwoOper() passed\n");

    /* assembles the context of response theory calculations */
    ierr = OpenRSPAssemble(open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPAssemble()");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPAssemble() passed\n");

    /* writes the context of response theory calculations */
    ierr = OpenRSPWrite(open_rsp, fp_log);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPWrite()");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPWrite() passed\n");

    /* sets the unperturbed AO-based Fock matrix */
    F_unpert[0] = (QcMat *)malloc(sizeof(QcMat));
    if (F_unpert[0]==NULL) {
        QErrorExit(FILE_AND_LINE, "allocates memory for Fock matrix");
    }
    ierr = QcMatCreate(F_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate(F)");
    ierr = OpenRSPTestReadMat(FOCK_AO_HF, 0, 1, F_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPTestReadMat(F)");
    /* sets the unperturbed AO-based density matrix */
    D_unpert[0] = (QcMat *)malloc(sizeof(QcMat));
    if (D_unpert[0]==NULL) {
        QErrorExit(FILE_AND_LINE, "allocates memory for density matrix");
    }
    ierr = QcMatCreate(D_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate(D)");
    ierr = OpenRSPTestReadMat(DENS_AO_HF, 0, 1, D_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPTestReadMat(D)");
    /* sets the unperturbed AO-based overlap integral matrix */
    S_unpert[0] = (QcMat *)malloc(sizeof(QcMat));
    if (S_unpert[0]==NULL) {
        QErrorExit(FILE_AND_LINE, "allocates memory for overlap integral matrix");
    }
    ierr = QcMatCreate(S_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatCreate(S)");
    ierr = OpenRSPTestReadMat(OVERLAP_AO, 0, 1, S_unpert);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPTestReadMat(S)");

    /* gets the polarizability */
    size_rsp_funs = 9;
    ierr = OpenRSPGetRSPFun(open_rsp,
                            F_unpert[0],
                            D_unpert[0],
                            S_unpert[0],
                            ALPHA_NUM_PROPS,
                            ALPHA_LEN_TUPLE,
                            ALPHA_PERT_TUPLE,
                            ALPHA_NUM_FREQ_CONFIGS,
                            ALPHA_PERT_FREQS,
                            ALPHA_KN_RULES,
                            size_rsp_funs,
                            rsp_funs);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPGetRSPFun()");
    fprintf(fp_log, "OpenRSPDensAOTest>> OpenRSPGetRSPFun() passed\n");
    for (ipert=0,ival=0; ipert<3; ipert++) {
        for (jpert=0; jpert<3; jpert++) {
            fprintf(fp_log,
                    " (%"QCREAL_FMT",%"QCREAL_FMT")",
                    rsp_funs[ival], rsp_funs[ival+1]);
            ival += 2;
        }
        fprintf(fp_log, "\n");
    }

    /* cleans */
    ierr = QcMatDestroy(F_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(F)");
    free(F_unpert[0]);
    F_unpert[0] = NULL;
    ierr = QcMatDestroy(D_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(D)");
    free(D_unpert[0]);
    D_unpert[0] = NULL;
    ierr = QcMatDestroy(S_unpert[0]);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling QcMatDestroy(S)");
    free(S_unpert[0]);
    S_unpert[0] = NULL;

    return QSUCCESS;
}

<<OpenRSPTest.h>>=
/*
  <<OpenRSPLicense>>

  This is the header file of OpenRSP unit testing.

  2014-07-31, Bin Gao:
  * first version
*/

#if !defined(OPENRSP_TEST_H)
#define OPENRSP_TEST_H

#include <string.h>
#include "OpenRSP.h"

#include "OpenRSPTestPerturbations.h"
#include "OpenRSPPertCallback.h"
#include "OpenRSPNucHamiltonCallback.h"
#include "OpenRSPDensAOTest.h"

#if !defined(OPENRSP_TEST_EXECUTABLE)
extern QErrorCode OpenRSPTest(FILE *fp_log);
#endif

#endif

<<OpenRSPTest.c>>=
/*
  <<OpenRSPLicense>>

   This file tests the APIs of OpenRSP library.

   2014-07-31, Bin Gao
   * first version
*/

#include "OpenRSPTest.h"

/* <macrodef name='OPENRSP_TEST_EXECUTABLE'>
     Build test suite as excutables.
   </macrodef> */
#if defined(OPENRSP_TEST_EXECUTABLE)
QErrorCode main()
{
    FILE *fp_log=stdout;  /* file pointer */
#else
QErrorCode OpenRSPTest(FILE *fp_log)
{
#endif
#include "OpenRSPTestPerturbations.h"
    OpenRSP open_rsp;  /* context of response theory calculations */
    QErrorCode ierr;   /* error information */

    /* creates the context of response theory calculations */
    ierr = OpenRSPCreate(&open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPCreate()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPCreate() passed\n");

    /* sets information of all perturbations */
    ierr = OpenRSPSetPerturbations(&open_rsp,
                                   NUM_ALL_PERT,
                                   ALL_PERT_LABELS,
                                   ALL_PERT_MAX_ORDERS,
                                   ALL_PERT_SIZES,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   (void *)PERT_CONTEXT,
#endif
                                   &get_pert_concatenation);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetPerturbations()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPSetPerturbations() passed\n");

    /* sets the nuclear Hamiltonian */
    ierr = OpenRSPSetNucHamilton(&open_rsp,
                                 NUM_ALL_PERT,
                                 ALL_PERT_LABELS,
                                 ALL_PERT_MAX_ORDERS,
#if defined(OPENRSP_C_USER_CONTEXT)   
                                 (void *)NUC_HAMILTON_CONTEXT,
#endif
                                 &get_nuc_contrib,
                                 NUM_ATOMS);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPSetNucHamilton()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPSetNucHamilton() passed\n");

    /* tests the density matrix-based response theory */
    ierr = OpenRSPDensAOTest(&open_rsp, fp_log);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPDensAOTest()");
    fprintf(fp_log, "OpenRSPTest>> density matrix-based response theory passed\n");

    /* destroys the context of response theory calculations */
    ierr = OpenRSPDestroy(&open_rsp);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling OpenRSPDestroy()");
    fprintf(fp_log, "OpenRSPTest>> OpenRSPDestroy() passed\n");

    return QSUCCESS;
}
@

\subsection{Testing Fortran APIs}

<<OpenRSPTest.F90>>=
!! <QcLang='Fortran'>
<<OpenRSPLicenseFortran>>
!!
!! This file tests the Fortran APIs of OpenRSP library.
!!
!! 2014-08-03, Bin Gao
!! * first version

