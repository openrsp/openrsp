\section{Perturbations}
\label{section-OpenRSP-perturbations}

The header file of perturbations is organized as:
<<RSPPerturbation.h>>=
/*
  <<OpenRSPLicense>>

  <header name='RSPPerturbation.h' author='Bin Gao' date='2015-06-23'>
    The header file of perturbations used inside OpenRSP
  </header>
*/

#if !defined(RSP_PERTURBATION_H)
#define RSP_PERTURBATION_H

/* QcMatrix library */
#include "qcmatrix.h"

<<RSPPertBasicTypes>>

<<RSPPertCallback>>

<<RSPPertStruct>>

<<RSPertAPIs>>

#endif
@

The chunk [[RSPPertBasicTypes]] defines some basic types used by \LibName for
perturbations. As described in Figure~\ref{fig-perturbation-label}, we will use
an unsigned integer to represent perturbation labels for both the host program
and the internal use of \LibName. The type of this unsigned integer
[[QcPertInt]]\index{[[QcPertInt]]} is defined as follows:
<<RSPPertBasicTypes>>=
/* <macrodef name='OPENRSP_PERT_SHORT_INT'>
     Represent perturbation labels using unsigned short integers
   </macrodef> */
#if defined(OPENRSP_PERT_SHORT_INT)
/* <datatype name='QcPertInt'>
     Data type of integers to represent perturbation labels
   </datatype>
   <constant name='QCPERTINT_MAX'>
     Maximal value of an object of the <QcPertInt> type
   </constant>
   <constant name='QCPERTINT_FMT'>
     Format string of <QcPertInt> type
   </constant> */
typedef unsigned short QcPertInt;
#define QCPERTINT_MAX USHRT_MAX
#define QCPERTINT_FMT "hu"
/* <macrodef name='OPENRSP_PERT_INT'>
     Represent perturbation labels using unsigned integers
   </macrodef> */
#elif defined(OPENRSP_PERT_INT)
typedef unsigned int QcPertInt;
#define QCPERTINT_MAX UINT_MAX
#define QCPERTINT_FMT "u"
#else
typedef unsigned long QcPertInt;
#define QCPERTINT_MAX ULONG_MAX
#define QCPERTINT_FMT "lu"
#endif
@ Here we allow users to choose either
[[unsigned short]]\index{[[OPENRSP_PERT_SHORT_INT]]},
[[unsigned int]]\index{[[OPENRSP_PERT_INT]]}, or [[unsigned long]] for the
type [[QcPertInt]]. We also define a constant
[[QCPERTINT_MAX]]\index{[[QCPERTINT_MAX]]} for the maximal value of an object
of the [[QcPertInt]] type, and a format string
([[QCPERTINT_FMT]]\index{[[QCPERTINT_FMT]]}) of the [[QcPertInt]] type.

We futher allow users to set the number of bits in an object of [[QcPertInt]]
for representing the host program's perturbation labels (see
Figure~\ref{fig-perturbation-label}). This can be done by changing the constant
[[OPENRSP_PERT_LABEL_BIT]]\index{[[OPENRSP_PERT_LABEL_BIT]]} during building:
<<RSPPertBasicTypes>>=
/* <macrodef name='OPENRSP_PERT_LABEL_BIT'>
     Set <OPENRSP_PERT_LABEL_BIT>
   </macrodef>
   <constant name='OPENRSP_PERT_LABEL_BIT'>
     Number of bits in an object of <QcPertInt> type for a perturbation label
   </constant> */
#if !defined(OPENRSP_PERT_LABEL_BIT)
#define OPENRSP_PERT_LABEL_BIT 10
#endif
@ and from which, and from the knowledge of [[QCPERTINT_MAX]] we can compute
[[OPENRSP_PERT_LABEL_MAX]]\index{[[OPENRSP_PERT_LABEL_MAX]]} and
[[OPENRSP_NUM_FREQ_MAX]]\index{[[OPENRSP_NUM_FREQ_MAX]]}, which are the maximal
values of perturbation labels and the number of frequencies allowed:
<<RSPPertBasicTypes>>=
/* <constant name='OPENRSP_PERT_LABEL_MAX'>
     Maximal value for perturbation labels
   </constant>
   <constant name='OPENRSP_NUM_FREQ_MAX'>
     Maximal value for number of frequencies
   </constant> */
extern const QcPertInt OPENRSP_PERT_LABEL_MAX;
extern const QcPertInt OPENRSP_NUM_FREQ_MAX;
@ Here, to avoid multiple inclusions of the header file that will lead to
multiple definitions, we have the following implementation file for the
[[OPENRSP_PERT_LABEL_MAX]] and [[OPENRSP_NUM_FREQ_MAX]]:
<<RSPPertLabel.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/* see https://scaryreasoner.wordpress.com/2009/02/28/checking-sizeof-at-compile-time
   accessing date Oct. 6, 2015 */
#define QC_BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
void RSPPertCheckLabelBit()
{
    QC_BUILD_BUG_ON(sizeof(QCPERTINT_MAX)*CHAR_BIT<=OPENRSP_PERT_LABEL_BIT);
}

const QcPertInt OPENRSP_PERT_LABEL_MAX = (1<<OPENRSP_PERT_LABEL_BIT)-1;
const QcPertInt OPENRSP_NUM_FREQ_MAX =
                (QCPERTINT_MAX-OPENRSP_PERT_LABEL_MAX)>>OPENRSP_PERT_LABEL_BIT;
@ The function [[RSPPertCheckLabelBit()]] ensures that
[[OPENRSP_PERT_LABEL_BIT]] is not too large and there are still bits left for
the number of frequencies. One will have building error when compiling the
function [[RSPPertCheckLabelBit()]] if [[OPENRSP_PERT_LABEL_BIT]] is too large.

However, the function [[RSPPertCheckLabelBit()]] can not guarantee the above
setting ([[QcPertInt]] type and [[OPENRSP_PERT_LABEL_BIT]]) is enough for
holding the host program's perturbation labels and the number of frequencies.
This will be checked against [[OPENRSP_PERT_LABEL_MAX]] and
[[OPENRSP_NUM_FREQ_MAX]] by \LibName when (i) setting the host program's
perturbations, and (ii) calculating response functions or residues.

As discussed in Section~\ref{subsection-analysis-perturbation}, we will need a
callback function [[get_pert_concatenation()]] to get the ranks of components
of sub-perturbation tuples (with the same perturbation label) for given
components of the corresponding concatenated perturbation tuple. The type of
this callback function is defined as follows:
<<RSPPertCallback>>=
typedef QVoid (*GetPertCat)(const QcPertInt,
                            const QInt,
                            const QInt,
                            const QInt,
                            const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                            QVoid*,
#endif
                            QInt*);
@

Also as mentioned in Section~\ref{subsection-analysis-perturbation}, \LibName
needs to know the numbers of components of host program's perturbations.
Because the number of components of a higher-order perturbation is simply the
product of numbers of components of lower-order perturbations with different
labels. For instance, the number of components of a perturbation
$a_{\omega_{a}}^{n_{a}}b_{\omega_{b}}^{n_{b}}$ is simply the product of numbers
of components of perturbations $a_{\omega_{a}}^{n_{a}}$ and
$b_{\omega_{b}}^{n_{b}}$.

Therefore, if there are in total $p$ different perturbation labels
$a_{1},a_{2},\cdots,a_{p}$ involved in calculations, \LibName needs to know
\begin{enumerate}
  \item allowed maximal order of a perturbation described by exactly
    \textbf{one} of these different labels $a_{1},a_{2},\cdots,a_{p}$; let
    us mark these allowed maximal orders as $n_{1},n_{2},\cdots,n_{p}$, which
    means we will have $k_{j}\le n_{j}$ ($1\le j\le p$) for any perturbation
    $a_{1,\omega_{1}}^{k_{1}}a_{2,\omega_{2}}^{k_{2}}\cdots a_{p,\omega_{p}}^{k_{p}}$;
  \item numbers of components of perturbations $a_{j,\omega_{j}}^{k_{j}}$,
    where $1\le k_{j}\le n_{j}$ and $1\le j\le p$; let us mark these numbers
    of components as $[N_{j}^{k_{j}}]$.
\end{enumerate}
The above information is saved into the following [[struct]]:
<<RSPPertStruct>>=
typedef struct {
    QcPertInt num_pert;                 /* number of different perturbation labels $p$ */
    QcPertInt *pert_labels;             /* $a_{1},a_{2},\cdots,a_{p}$ */
    QInt *pert_max_orders;              /* $n_{1},n_{2},\cdots,n_{p}$ */
    QInt *ptr_ncomp;                    /* pointers to $[N_{j}^{k_{j}}]$
                                           for each $a_{j}$ */
    QInt *pert_num_comps;               /* $[N_{j}^{k_{j}}]$, where
                                           $1\le k_{j}\le n_{j}$ and $1\le j\le p$ */
#if defined(OPENRSP_C_USER_CONTEXT)     
    QVoid *user_ctx;                    /* user-defined callback function context */
#endif
    GetPertCat get_pert_concatenation;  /* user specified function for getting
                                           the ranks of components of sub-perturbation
                                           tuples (with the same perturbation label)
                                           for given components of the corresponding
                                           concatenated perturbation tuple */
} RSPPert;
@ and users can set the above information by the following API:
\index{[[OpenRSPSetPerturbations()]]}
<<OpenRSPSetPerturbations.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "OpenRSP.h"

/* <function name='OpenRSPSetPerturbations' author='Bin Gao' date='2015-06-29'>
     Sets all perturbations involved in response theory calculations
     <param name='open_rsp' direction='inout'>The OpenRSP context</param>
     <param name='num_pert' direction='in'>
       Number of all different perturbation labels involved in calculations
     </param>
     <param name='pert_labels' direction='in'>
       All the different perturbation labels involved
     </param>
     <param name='pert_max_orders' direction='in'>
       Allowed maximal order of a perturbation described by exactly one of
       the above different labels
     </param>
     <param name='pert_num_comps' direction='in'>
       Number of components of a perturbation described by exactly one of
       the above different labels, up to the allowed maximal order, size
       is therefore the sum of <pert_max_orders>
     </param>
     <param name='user_ctx' direction='in'>
       User-defined callback function context
     </param>
     <param name='get_pert_concatenation' direction='in'>
       User specified function for getting the ranks of components of
       sub-perturbation tuples (with the same perturbation label) for given
       components of the corresponding concatenated perturbation tuple
     </param>
     <return>Error information</return>
   </function> */
QErrorCode OpenRSPSetPerturbations(OpenRSP *open_rsp,
                                   const QcPertInt num_pert,
                                   const QcPertInt *pert_labels,
                                   const QInt *pert_max_orders,
                                   const QInt *pert_num_comps,
#if defined(OPENRSP_C_USER_CONTEXT)
                                   QVoid *user_ctx,
#endif
                                   const GetPertCat get_pert_concatenation)
{
    QErrorCode ierr;  /* error information */
    /* creates the context of all perturbations involved in calculations */
    if (open_rsp->rsp_pert!=NULL) {
        ierr = RSPPertDestroy(open_rsp->rsp_pert);
        QErrorCheckCode(ierr, FILE_AND_LINE, "calling RSPPertDestroy()");
    }
    else {
        open_rsp->rsp_pert = (RSPPert *)malloc(sizeof(RSPPert));
        if (open_rsp->rsp_pert==NULL) {
            QErrorExit(FILE_AND_LINE, "allocates memory for perturbations");
        }
    }
    ierr = RSPPertCreate(open_rsp->rsp_pert,
                         num_pert,
                         pert_labels,
                         pert_max_orders,
                         pert_num_comps,
#if defined(OPENRSP_C_USER_CONTEXT)
                         user_ctx,
#endif
                         get_pert_concatenation);
    QErrorCheckCode(ierr, FILE_AND_LINE, "calling RSPPertCreate()");
    return QSUCCESS;
}
@

The APIs [[RSPPertCreate()]] and [[RSPPertDestroy()]] will respectively create
and destroy the content of the [[struct]] [[RSPPert]]. We have the following
APIs for the [[struct]] [[RSPPert]]:
<<RSPertAPIs>>=
extern QErrorCode RSPPertCreate(RSPPert*,
                                const QcPertInt,
                                const QcPertInt*,
                                const QInt*,
                                const QInt*,
#if defined(OPENRSP_C_USER_CONTEXT)
                                QVoid*,
#endif
                                const GetPertCat);
extern QErrorCode RSPPertAssemble(RSPPert*);
extern QErrorCode RSPPertWrite(const RSPPert*,FILE*);
//extern QErrorCode RSPPertGetFromTuple(const RSPPert*,
//                                      const QInt,
//                                      const QcPertInt*,
//                                      const QcPertInt,
//                                      const QReal*,
//                                      QInt*);
extern QErrorCode RSPPertGetConcatenation(const RSPPert*,
                                          const QcPertInt,
                                          const QInt,
                                          const QInt,
                                          const QInt,
                                          const QInt*,
                                          QInt*);
extern QErrorCode RSPPertDestroy(RSPPert*);
@ which are respectively implemented in the following different files:
<<RSPPertCreate.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/*% \brief sets all perturbations involved in response theory calculations
    \author Bin Gao
    \date 2015-06-28
    \param[RSPPert:struct]{inout} rsp_pert context of all perturbations involved in calculations
    \param[QInt:int]{in} num_pert number of all different perturbation labels involved
        in calculations
    \param[QInt:int]{in} pert_labels all different perturbation labels involved
    \param[QInt:int]{in} pert_max_orders maximum allowed order of each perturbation (label)
    \param[QInt:int]{in} pert_num_comps number of components of each perturbation (label)
        up to its maximum order, size is \sum{\var{pert_max_orders}}
    \param[QVoid:void]{in} user_ctx user-defined callback function context
    \param[GetPertCat:void]{in} get_pert_concatenation user specified function for
        getting the ranks of components of sub-perturbation tuples (with same
        perturbation label) for given components of the corresponding concatenated
        perturbation tuple
    \return[QErrorCode:int] error information
*/
QErrorCode RSPPertCreate(RSPPert *rsp_pert,
                         const QcPertInt num_pert,
                         const QcPertInt *pert_labels,
                         const QInt *pert_max_orders,
                         const QInt *pert_num_comps,
#if defined(OPENRSP_C_USER_CONTEXT)
                         QVoid *user_ctx,
#endif
                         const GetPertCat get_pert_concatenation)
{
    QInt ipert;   /* incremental recorders over perturbations */
    QInt jpert;
    QInt iorder;  /* incremental recorder over orders */
    if (num_pert<1) {
        printf("RSPPertCreate>> number of perturbation labels %"QCPERTINT_FMT"\n",
               num_pert);
        QErrorExit(FILE_AND_LINE, "invalid number of perturbation labels");
    }
    else if (num_pert>OPENRSP_PERT_LABEL_MAX) {
        printf("RSPPertCreate>> number of perturbation labels %"QCPERTINT_FMT"\n",
               num_pert);
        printf("RSPPertCreate>> maximal value for pert. labels %"QCPERTINT_FMT"\n",
               OPENRSP_PERT_LABEL_MAX);
        QErrorExit(FILE_AND_LINE, "too many perturbation labels");
    }
    rsp_pert->num_pert = num_pert;
    rsp_pert->pert_labels = (QcPertInt *)malloc(num_pert*sizeof(QcPertInt));
    if (rsp_pert->pert_labels==NULL) {
        printf("RSPPertCreate>> number of perturbation labels %"QCPERTINT_FMT"\n",
               num_pert);
        QErrorExit(FILE_AND_LINE, "allocates memory for perturbation labels");
    }
    rsp_pert->pert_max_orders = (QInt *)malloc(num_pert*sizeof(QInt));
    if (rsp_pert->pert_max_orders==NULL) {
        printf("RSPPertCreate>> number of perturbation labels %"QCPERTINT_FMT"\n",
               num_pert);
        QErrorExit(FILE_AND_LINE, "allocates memory for allowed maximal orders");
    }
    rsp_pert->ptr_ncomp = (QInt *)malloc((num_pert+1)*sizeof(QInt));
    if (rsp_pert->ptr_ncomp==NULL) {
        printf("RSPPertCreate>> number of perturbation labels %"QCPERTINT_FMT"\n",
               num_pert);
        QErrorExit(FILE_AND_LINE, "allocates memory for pointers to components");
    }
    rsp_pert->ptr_ncomp[0] = 0;
    for (ipert=0; ipert<num_pert; ipert++) {
        if (pert_labels[ipert]>OPENRSP_PERT_LABEL_MAX) {
            printf("RSPPertCreate>> %"QINT_FMT"-th pert. label %"QCPERTINT_FMT"\n",
                   ipert,
                   pert_labels[ipert]);
            printf("RSPPertCreate>> maximal value for pert. labels %"QCPERTINT_FMT"\n",
                   OPENRSP_PERT_LABEL_MAX);
            QErrorExit(FILE_AND_LINE, "invalid perturbation label");
        }
        /* each element of <pert_labels> should be unique */
        for (jpert=0; jpert<ipert; jpert++) {
            if (pert_labels[jpert]==pert_labels[ipert]) {
                printf("RSPPertCreate>> %"QINT_FMT"-th pert. label %"QCPERTINT_FMT"\n",
                       jpert,
                       pert_labels[jpert]);
                printf("RSPPertCreate>> %"QINT_FMT"-th pert. label %"QCPERTINT_FMT"\n",
                       ipert,
                       pert_labels[ipert]);
                QErrorExit(FILE_AND_LINE, "repeated perturbation labels not allowed");
            }
        }
        rsp_pert->pert_labels[ipert] = pert_labels[ipert];
        if (pert_max_orders[ipert]<1) {
            printf("RSPPertCreate>> %"QINT_FMT"-th pert. label %"QCPERTINT_FMT"\n",
                   ipert,
                   pert_labels[ipert]);
            printf("RSPPertCreate>> allowed maximal order is %"QINT_FMT"\n",
                   pert_max_orders[ipert]);
            QErrorExit(FILE_AND_LINE, "only positive order allowed");
        }
        rsp_pert->pert_max_orders[ipert] = pert_max_orders[ipert];
        /* <c>rsp_pert->ptr_ncomp[ipert]</c> points to the number of components
           of <c>rsp_pert->pert_labels[ipert]</c> */
        rsp_pert->ptr_ncomp[ipert+1] = rsp_pert->ptr_ncomp[ipert]
                                     + pert_max_orders[ipert];
    }
    /* <c>rsp_pert->ptr_ncomp[num_pert]</c> equals to the size of
       <c>rsp_pert->pert_num_comps</c> */
    rsp_pert->pert_num_comps = (QInt *)malloc(rsp_pert->ptr_ncomp[num_pert]
                                              *sizeof(QInt));
    if (rsp_pert->pert_num_comps==NULL) {
        printf("RSPPertCreate>> size of numbers of components %"QINT_FMT"\n",
               rsp_pert->ptr_ncomp[num_pert]);
        QErrorExit(FILE_AND_LINE, "allocates memory for numbers of components");
    }
    for (ipert=0,jpert=0; ipert<num_pert; ipert++) {
        for (iorder=1; iorder<=rsp_pert->pert_max_orders[ipert]; iorder++,jpert++) {
            if (pert_num_comps[jpert]<1) {
                printf("RSPPertCreate>> %"QINT_FMT"-th pert. label %"QCPERTINT_FMT"\n",
                       ipert,
                       pert_labels[ipert]);
                printf("RSPPertCreate>> allowed maximal order is %"QINT_FMT"\n",
                       pert_max_orders[ipert]);
                printf("RSPPertCreate>> number of components is %"QINT_FMT"\n",
                       pert_num_comps[jpert]);
                QErrorExit(FILE_AND_LINE, "incorrect number of components");
            }
            rsp_pert->pert_num_comps[jpert] = pert_num_comps[jpert];
        }
    }
#if defined(OPENRSP_C_USER_CONTEXT)
    rsp_pert->user_ctx = user_ctx;
#endif
    rsp_pert->get_pert_concatenation = get_pert_concatenation;
    return QSUCCESS;
}
@ Here we check the number of perturbation labels and each label against
[[OPENRSP_PERT_LABEL_MAX]].

<<RSPPertAssemble.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/*% \brief assembles the context of all perturbations involved in calculations
    \author Bin Gao
    \date 2015-06-28
    \param[RSPPert:struct]{inout} rsp_pert context of all perturbations involved in calculations
    \return[QErrorCode:int] error information
*/
QErrorCode RSPPertAssemble(RSPPert *rsp_pert)
{
    if (rsp_pert->pert_labels==NULL ||
        rsp_pert->pert_max_orders==NULL ||
        rsp_pert->ptr_ncomp==NULL ||
        rsp_pert->pert_num_comps==NULL ||
        rsp_pert->get_pert_concatenation==NULL) {
        QErrorExit(FILE_AND_LINE, "perturbations are not correctly set");
    }
    return QSUCCESS;
}

<<RSPPertWrite.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/*% \brief writes the context of all perturbations involved in calculations
    \author Bin Gao
    \date 2015-06-28
    \param[RSPPert:struct]{inout} rsp_pert context of all perturbations involved in calculations
    \param[FILE]{inout} fp_pert file pointer
    \return[QErrorCode:int] error information
*/
QErrorCode RSPPertWrite(const RSPPert *rsp_pert, FILE *fp_pert)
{
    QInt ipert,icomp;  /* incremental recorders */
    fprintf(fp_pert,
            "RSPPertWrite>> number of all perturbation lables %"QCPERTINT_FMT"\n",
            rsp_pert->num_pert);
    fprintf(fp_pert,
            "RSPPertWrite>> label           maximum-order    numbers-of-components\n");
    for (ipert=0; ipert<rsp_pert->num_pert; ipert++) {
        fprintf(fp_pert,
                "RSPPertWrite>>  %"QCPERTINT_FMT"               %"QINT_FMT"               ",
                rsp_pert->pert_labels[ipert],
                rsp_pert->pert_max_orders[ipert]);
        for (icomp=rsp_pert->ptr_ncomp[ipert]; icomp<rsp_pert->ptr_ncomp[ipert+1]; icomp++) {
            fprintf(fp_pert, " %"QINT_FMT"", rsp_pert->pert_num_comps[icomp]);
        }
        fprintf(fp_pert, "\n");
    }
#if defined(OPENRSP_C_USER_CONTEXT)
    if (rsp_pert->user_ctx!=NULL) {
        fprintf(fp_pert, "RSPPertWrite>> user-defined function context given\n");
    }
#endif
    return QSUCCESS;
}

<<RSPPertGetFromTuple.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/*% \brief gets the information of perturbations (orders and number of components)
        from a given perturbation tuple
    \author Bin Gao
    \date 2015-06-29
    \param[RSPPert:struct]{in} rsp_pert context of all perturbations involved
        in calculations
    \param[QInt:int]{in} len_tuple length of the perturbation tuple, in which
        identical perturbation labels should be consecutive
    \param[QInt:int]{in} pert_tuple the perturbation tuple
    \param[QInt:int]{in} num_freq_configs number of different frequency configurations
    \param[QReal:real]{in} pert_freqs complex frequencies of each perturbation label
        over all frequency configurations
    \var[QInt:int]{out} num_pert number of different perturbations from the given
        perturbation tuple
    \var[QInt:int]{out} pert_orders orders of each perturbation
    \var[QInt:int]{out} pert_num_comps numbers of components of each perturbation,
        from the first order up to the order in \var{pert_orders}
    \return[QErrorCode:int] error information
*/
//QErrorCode RSPPertGetFromTuple(const RSPPert *rsp_pert,
//                               const QInt len_tuple,
//                               const QcPertInt *pert_tuple,
//                               const QcPertInt num_freq_configs,
//                               const QReal *pert_freqs,
//                               QInt *num_pert,
//                               QInt *pert_orders,
//                               QInt *pert_num_comps)
//{
//    QInt ipert,jpert;  /* incremental recorders */
//    QInt first_id;     /* first identical pertubation label in the tuple */
//    QInt last_id;      /* last identical pertubation label in the tuple */
//    QBool non_id;      /* indicates if non-identical label found */
//    /* we first get the consecutive identical pertubation labels */
//    first_id = 0;
//    non_id = QFALSE;
//    for (ipert=first_id; ipert<len_tuple-1; ipert++) {
//        if (pert_tuple[ipert]!=pert_tuple[ipert+1]) {
//            last_id = ipert;
//            non_id = QTRUE;
//            break;
//        }
//    }
//    if (non_id=QTRUE) {
//    }
//    else {
//    }
//    /* loops over all known perturbation labels and checks if they are in the tuple */
//    for (ipert=0; ipert<rsp_pert->num_pert; ipert++) {
//        /* loops over perturbation labels in the tuple */
//        for (ipert=first_id; ipert<len_tuple; ipert++) {
//            /* checks if the given label is known */
//            if (pert_tuple[ipert]==rsp_pert->pert_labels[jpert]) {
//                
//            }
//        }
//    }
//    return QSUCCESS;
//}

<<RSPPertGetConcatenation.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/*% \brief gets the ranks of components of sub-perturbation tuples (with
        same perturbation label) for given components of the corresponding
        concatenated perturbation tuple
    \author Bin Gao
    \date 2015-06-28
    \param[RSPPert:struct]{in} rsp_pert context of all perturbations involved
        in calculations
    \param[QInt:int]{in} pert_label the perturbation label
    \param[QInt:int]{in} first_cat_comp rank of the first component of the
        concatenated perturbation tuple
    \param[QInt:int]{in} num_cat_comps number of components of the concatenated
        perturbation tuple
    \param[QInt:int]{in} num_sub_tuples number of sub-perturbation tuples to
        construct the concatenated perturbation tuple
    \param[QInt:int]{in} len_sub_tuples length of each sub-perturbation tuple,
        size is ``num_sub_tuples``; so that the length of the concatenated
        perturbation is ``sum(len_sub_tuples)``
    \var[QInt:int]{out} rank_sub_comps ranks of components of sub-perturbation
        tuples for the corresponding component of the concatenated perturbation
        tuple, i.e. ``num_cat_comps`` components starting from the one with rank
        ``first_cat_comp``, size is therefore ``num_sub_tuples*num_cat_comps``,
        and arranged as ``[num_cat_comps][num_sub_tuples]``
    \return[QErrorCode:int] error information
*/
QErrorCode RSPPertGetConcatenation(const RSPPert *rsp_pert,
                                   const QcPertInt pert_label,
                                   const QInt first_cat_comp,
                                   const QInt num_cat_comps,
                                   const QInt num_sub_tuples,
                                   const QInt *len_sub_tuples,
                                   QInt *rank_sub_comps)
{
/*FIXME: zero-based or one-based numbering*/
    rsp_pert->get_pert_concatenation(pert_label,
                                     first_cat_comp,
                                     num_cat_comps,
                                     num_sub_tuples,
                                     len_sub_tuples,
#if defined(OPENRSP_C_USER_CONTEXT)
                                     rsp_pert->user_ctx,
#endif
                                     rank_sub_comps);
    return QSUCCESS;
}

<<RSPPertDestroy.c>>=
/*
  <<OpenRSPLicense>>
*/

#include "RSPPerturbation.h"

/*% \brief destroys the context of all perturbations involved in calculations
    \author Bin Gao
    \date 2015-06-28
    \param[RSPPert:struct]{inout} rsp_pert context of all perturbations involved in calculations
    \return[QErrorCode:int] error information
*/
QErrorCode RSPPertDestroy(RSPPert *rsp_pert)
{
    rsp_pert->num_pert = 0;
    free(rsp_pert->pert_labels);
    rsp_pert->pert_labels = NULL;
    free(rsp_pert->pert_max_orders);
    rsp_pert->pert_max_orders = NULL;
    free(rsp_pert->ptr_ncomp);
    rsp_pert->ptr_ncomp = NULL;
    free(rsp_pert->pert_num_comps);
    rsp_pert->pert_num_comps = NULL;
#if defined(OPENRSP_C_USER_CONTEXT)
    rsp_pert->user_ctx = NULL;
#endif
    rsp_pert->get_pert_concatenation = NULL;
    return QSUCCESS;
}

