#!/usr/bin/env python

# runtest - script to run tests and compare results with reference data
# (c) Radovan Bast (radovan.bast at gmail.com) and friends 2010-2012
# licensed under the GNU Lesser General Public License

import re
import os
import sys
import string
import subprocess
import shlex
import time
import shutil
import signal
import glob
from optparse import OptionParser, OptionGroup

#-------------------------------------------------------------------------------

if sys.version < '2.4':
    print('runtest requires python version >= 2.4')
    sys.exit(1)

#-------------------------------------------------------------------------------
# global variables

root_directory = os.path.dirname(os.path.realpath(__file__))
current_directory = os.path.realpath('.')

program_is_dirac  = False
program_is_dalton = True

program_group_id = None

#-------------------------------------------------------------------------------

def kill_win(pid):
    """
    kill process on  Win32
    http://docs.python.org/faq/windows.html#id11
    see also http://code.activestate.com/recipes/347462-terminating-a-subprocess-on-windows/
    """
    import ctypes
    kernel32 = ctypes.windll.kernel32
    handle = kernel32.OpenProcess(1, 0, pid)
    return (0 != kernel32.TerminateProcess(handle, 0))

#-------------------------------------------------------------------------------

def extract_time(time_string):
    # extract time (in seconds) from the entering time string "hh:mm:ss"
    # returns time in secs
    hours   = int(time_string.split(':')[0])
    minutes = int(time_string.split(':')[1])
    seconds = int(time_string.split(':')[2])
    return seconds + 60*minutes + 60*60*hours

#-------------------------------------------------------------------------------
# parse input

# define example usage

usage = '''
  typically ./%prog --all [--mpi=4]
         or ./%prog --tests=some_test
         or ./%prog --tests="some_test another_test"'''

# initialize parser

parser = OptionParser(usage)

# define options

group = OptionGroup(parser, 'Select the test set')
group.add_option('--all',
                 action='store_true',
                 dest='all',
                 default=False,
                 help='run all tests [default: %default]')
group.add_option('--tests',
                 type='string',
                 action='store',
                 dest='individual',
                 default=None,
                 help='select individual test(s)',
                 metavar='\"test1 test2 anothertest\"')
group.add_option('--quick',
                 action='store_true',
                 dest='quick',
                 default=False,
                 help='run only a subset that is quick but has less coverage [default: %default]')
group.add_option('--benchmark',
                 action='store_true',
                 dest='benchmark',
                 default=False,
                 help='run only benchmark runs [default: %default]')
parser.add_option_group(group)

group = OptionGroup(parser, 'MPI parallelization')
group.add_option('--mpi',
                 type='int',
                 action='store',
                 dest='mpi',
                 default=1,
                 help='set number of cores [default: %default]',
                 metavar='INTEGER')
parser.add_option_group(group)

group = OptionGroup(parser, 'Change default paths')
if program_is_dirac:
    group.add_option('--binary',
                     dest='binary',
                     default=None,
                     help='full path to binary to test')
if program_is_dalton:
    group.add_option('--launcher',
                     dest='launcher',
                     default=None,
                     help='full path to launcher (dalton script)')
parser.add_option_group(group)

group = OptionGroup(parser, 'Development options')
group.add_option('--giveup',
                 action='store_true',
                 dest='giveup',
                 default=False,
                 help='give up after first failing test [default: %default]')
group.add_option('--timeout',
                 action='store',
                 dest='timeout',
                 default=None,
                 help='time limit for runtest [default: %default]',
                 metavar='"hh:mm:ss"')
group.add_option('--backup',
                 action='store_true',
                 dest='backup',
                 default=False,
                 help='backup pam output files with archive files [default: %default]')
group.add_option('--verbose',
                 action='store_true',
                 dest='verbose',
                 default=False,
                 help="verbose output, if, you know, you're not into the whole brevity thing [default: %default]")
group.add_option('--showdiff',
                 action='store_true',
                 dest='showdiff',
                 default=False,
                 help="show differences in numbers [default: %default]")
group.add_option('--jobargs',
                 action='store',
                 dest='jobargs',
                 default=None,
                 help="extra arguments to launcher [default: %default]")
parser.add_option_group(group)

# process input

(options, args) = parser.parse_args()

#-------------------------------------------------------------------------------
# get list of tests to run

list_of_tests_to_run = []

executed_from_subdir = os.path.isfile(os.path.join(current_directory,'menu'))
if len(sys.argv) == 1:
    if executed_from_subdir:
        list_of_tests_to_run.append(current_directory)
    else:
        # user has given no arguments and we are not in a test subdir: print help and exit
        print(parser.format_help().strip())
        sys.exit()

if options.individual:
    if options.individual.split() == ['all']:
        options.all        = True
        options.individual = False
    else:
        for w in options.individual.split():
            test_to_append=os.path.join(root_directory, 'test', w)
            list_of_tests_to_run.append(test_to_append)

if options.all or (options.quick and not options.individual):
    file = os.path.join(root_directory,'test','list_of_tests')
    if os.path.isfile(file):
        f = open(file, 'r')
        for line in f.readlines():
            test_to_append=os.path.join(root_directory,'test',line.strip('\n'))
            list_of_tests_to_run.append(test_to_append)
        f.close()
    else:
        print('file %s does not exist' % file)
        sys.exit()

#-------------------------------------------------------------------------------

def int32_run(s):
    for line in s:
        if '64-bit integers' in line:
            if (line.split()[-1] == 'ON' or line.split()[-1] == '1'):
                return False
    return True

#-------------------------------------------------------------------------------

class filter_task:
     def __init__(self, precision, ignore_below_limit, ignore_sign, start_string, start_is_regex, \
                  end_string='', end_is_regex=False, end_is_including=False, plus_nr_lines=0, \
                  compare_everything=False, nr_of_floats=0):
         self.precision          = precision
         self.ignore_below_limit = ignore_below_limit
         self.ignore_sign        = ignore_sign
         self.nr_of_floats       = nr_of_floats
         self.start_string       = start_string
         self.start_is_regex     = start_is_regex
         self.end_string         = end_string
         self.end_is_regex       = end_is_regex
         self.end_is_including   = end_is_including
         self.plus_nr_lines      = plus_nr_lines
         self.compare_everything = compare_everything

#-------------------------------------------------------------------------------

def set_filter_defaults():
    precision         = 0.0001
    ignore_below_limit= 1.0e-40
    ignore_sign       = False
    start_string      = ''
    start_is_regex    = False
    return (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex)

#-------------------------------------------------------------------------------

def read_filter(filter_file):

    s = open(filter_file).readlines()
    filter_task_l = []

    (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex) = set_filter_defaults()

    nr_of_floats = 0

    for line in s:
        # the syntax ($ERROR, $IGNORESIGN, ...) is for backwards compatibility
        # with DIRAC's old perl scripts - if you change it here, please change it globally in DIRAC repo
        if '$ERROR' in line:
            precision = float(line.split()[-1])
        if '$IGNORE_BELOW' in line:
            ignore_below_limit = float(line.split()[-1])
        if '$IGNORESIGN' in line:
            ignore_sign = True
        if '$NR_OF_FLOATS' in line:
            nr_of_floats = int(line.split()[-1])
        if (line.lower()[0:10] == 'everything'):
            filter_task_l.append(filter_task(precision,      \
                                             ignore_below_limit, \
                                             ignore_sign,    \
                                             start_string,   \
                                             start_is_regex, \
                                             compare_everything=True, \
                                             nr_of_floats=nr_of_floats))
            (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex) = set_filter_defaults()
        if (line.lower()[0:5] == 'from:'):
            start_string = line[5:].rstrip()
        if (line.lower()[0:7] == 'fromre:'):
            start_string = line[7:].rstrip()
            start_is_regex = True
        if (line.lower()[0:6] == 'nlines'):
            nr_lines = int(line.split(':')[0].split()[-1])
            start_string = line.split(line.split(':')[0] + ':')[-1].rstrip()
            filter_task_l.append(filter_task(precision,      \
                                             ignore_below_limit, \
                                             ignore_sign,    \
                                             start_string,   \
                                             start_is_regex, \
                                             plus_nr_lines=nr_lines, \
                                             nr_of_floats=nr_of_floats))
            (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex) = set_filter_defaults()
        if (line.lower()[0:3] == 'to:'):
            filter_task_l.append(filter_task(precision,      \
                                             ignore_below_limit, \
                                             ignore_sign,    \
                                             start_string,   \
                                             start_is_regex, \
                                             end_string=line[3:].rstrip(), \
                                             nr_of_floats=nr_of_floats))
            (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex) = set_filter_defaults()
        if (line.lower()[0:5] == 'tore:'):
            filter_task_l.append(filter_task(precision,                    \
                                             ignore_below_limit,           \
                                             ignore_sign,                  \
                                             start_string,                 \
                                             start_is_regex,               \
                                             end_string=line[5:].rstrip(), \
                                             end_is_regex=True, \
                                             nr_of_floats=nr_of_floats))
            (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex) = set_filter_defaults()
        if (line.lower()[0:4] == 'toi:'):
            filter_task_l.append(filter_task(precision,                    \
                                             ignore_below_limit,           \
                                             ignore_sign,                  \
                                             start_string,                 \
                                             start_is_regex,               \
                                             end_string=line[4:].rstrip(), \
                                             end_is_including=True, \
                                             nr_of_floats=nr_of_floats))
            (precision, ignore_below_limit, ignore_sign, start_string, start_is_regex) = set_filter_defaults()
        if (line.lower()[0:6] == 'toire:'):
            filter_task_l.append(filter_task(precision,                    \
                                             ignore_below_limit,           \
                                             ignore_sign,                  \
                                             start_string,                 \
                                             start_is_regex,               \
                                             end_string=line[6:].rstrip(), \
                                             end_is_regex=True,            \
                                             end_is_including=True, \
                                             nr_of_floats=nr_of_floats))
            (precision, ignore_below_limt, ignore_sign, start_string, start_is_regex) = set_filter_defaults()

    return filter_task_l

#-------------------------------------------------------------------------------

def extract_and_compare_floats(log_file,     \
                               output,       \
                               output_ref,   \
                               line_l,       \
                               line_l_ref,   \
                               nr_of_floats, \
                               precision,    \
                               ignore_below_limit,    \
                               ignore_sign):
    """
    in:  output      a list of strings (= a file)
         output_ref  a list of strings (= a file)
         line_l      list of integers that correspond to line numbers in python numbering
         line_l_ref  list of integers that correspond to line numbers in python numbering
    if nr_of_floats > 0 then it will only compare the first nr_of_floats in each line
    """

    numeric_const_pattern = r"""
    [-+]? # optional sign
    (?:
        (?: \d* \. \d+ ) # .1 .12 .123 etc 9.1 etc 98.1 etc
        |
        (?: \d+ \.? ) # 1. 12. 123. etc 1 12 123 etc
    )
    # followed by optional exponent part if desired
    (?: [EeDd] [+-]? \d+ ) ?
    """

    p  = re.compile(numeric_const_pattern, re.VERBOSE)
    pd = re.compile(r'[dD]')

    f_l           = []
    f_l_ref       = []
    f_to_line     = []
    f_to_line_ref = []
    for x in line_l:
        for line in x:
            i = 0
            for w in output[line].split():
                i += 1
                if (nr_of_floats > 0) and (i > nr_of_floats): break
                # do not consider words like TzB1g
                # otherwise we would extract 1 later
                if re.match(r'^[0-9\.eEdD\+\-]*$', w):
                    # apply floating point regex
                    for m in p.findall(w):
                         # substitute dD by e
                         m = pd.sub('e', m)
                         f_l.append(float(m))
                         f_to_line.append(line)

    for x in line_l_ref:
        for line in x:
            i = 0
            for w in output_ref[line].split():
                i += 1
                if (nr_of_floats > 0) and (i > nr_of_floats): break
                if re.match(r'^[0-9\.eEdD\+\-]*$', w):
                    for m in p.findall(w):
                         m = pd.sub('e', m)
                         f_l_ref.append(float(m))
                         f_to_line_ref.append(line)

    if len(f_l) == len(f_l_ref):
        for i in range(len(f_l)):
            r     = f_l[i]
            r_ref = f_l_ref[i]

            if ignore_sign:
                # if ignore sign take absolute values
                r     = abs(r)
                r_ref = abs(r_ref)
            error = r - r_ref

            if program_is_dirac:
                rel_error = error
                if abs(r_ref) > ignore_below_limit:
                    # calculate relative error only for significant ('nonzero') numbers
                    rel_error /= r_ref
                if abs(rel_error) > precision:
                    log_file.write('line %i: %s' % (f_to_line[i]+1, output[f_to_line[i]]))
                    log_file.write('            relative error=%19.16f\n' % rel_error)
                    log_file.write('desired relative precision=%19.16f\n' % precision)
            if program_is_dalton:
                if abs(error) > precision:
                    log_file.write('line %i: %s' % (f_to_line[i]+1, output[f_to_line[i]]))
                    log_file.write('            error=%19.16f\n' % error)
                    log_file.write('desired precision=%19.16f\n' % precision)
    else:
        log_file.write('compare floats sizes do not match\n')

        log_file.write('own gave %i floats:\n' % len(f_l))
        last_line_printed = -1
        for i in range(len(f_l)):
            if (f_to_line[i] != last_line_printed):
               log_file.write('    %s' % output[f_to_line[i]])
               last_line_printed = f_to_line[i]

        log_file.write('refence gave %i floats:\n' % len(f_l_ref))
        last_line_printed = -1
        for i in range(len(f_l_ref)):
            if (f_to_line_ref[i] != last_line_printed):
               log_file.write('    %s' % output_ref[f_to_line_ref[i]])
               last_line_printed = f_to_line_ref[i]

#-------------------------------------------------------------------------------

def find_from_to(output,         \
                 start_string,   \
                 start_is_regex, \
                 end_string,     \
                 end_is_regex,   \
                 end_is_including):

    if start_is_regex:
        ps = re.compile(r'.*%s' % start_string)
    if end_is_regex:
        pe = re.compile(r'.*%s' % end_string)

    line_l = []
    for i in range(len(output)):
        start_line_matches = False
        if start_is_regex:
            start_line_matches = ps.match(output[i])
        else:
            start_line_matches = (start_string in output[i])
        if start_line_matches:
            for j in range(i, len(output)):
                end_line_matches = False
                if end_is_regex:
                    end_line_matches = pe.match(output[j])
                else:
                    end_line_matches = (end_string in output[j])
                if end_line_matches:
                    if end_is_including:
                        line_l.append(range(i, j+1))
                        break
                    else:
                        line_l.append(range(i, j))
                        break

    return line_l

#-------------------------------------------------------------------------------

def find_string_plus_nr_lines(output, start_string, n, start_is_regex=False):

    if start_is_regex:
        p = re.compile(r'.*%s' % start_string)

    line_l = []
    for i in range(len(output)):
        start_line_matches = False
        if start_is_regex:
            start_line_matches = p.match(output[i])
        else:
            start_line_matches = (start_string in output[i])
        if start_line_matches:
            line_l.append(range(i, i+n))

    return line_l

#-------------------------------------------------------------------------------

class run:
     def __init__(self, test, line, kind):
         self.test = test
         self.kind = kind
         launcher_flags = ''

         if (line.split()[0] == 'noref'):
             self.noref = True
             self.inp   = line.split()[1]
             self.mol   = line.split()[2]
         else:
             self.noref = False
             self.inp   = line.split()[0]
             self.mol   = line.split()[1]

         if program_is_dirac:
             # pretty please no timeout when executed interactively
             if not executed_from_subdir:
                # default timeouts for quick, regular and benchmark tests
                if self.kind == 'q':
                    launcher_flags +=  '--timeout=21m '
                elif self.kind == 'r':
                    launcher_flags +=  '--timeout=21m '
                else:
                    launcher_flags +=  '--timeout=1h '

         if len(line.split()) > 2:
             for i in range(2, len(line.split())):
                 launcher_flags += line.split()[i] + ' '
         if program_is_dirac:
             if not options.verbose:
                 launcher_flags += '--silent '
             if not options.backup:
                 launcher_flags += '--nobackup '
                 launcher_flags += '--noarch '
             if options.binary:
                 launcher_flags += '--dirac=%s ' % options.binary
             if options.jobargs:
                 launcher_flags += ' %s ' % options.jobargs
             if options.mpi > 1:
                 launcher_flags += '--mpi=%i ' % options.mpi
         if program_is_dalton:
             launcher_flags += '-nobackup '
             launcher_flags += '-noarch '
             if options.mpi > 1:
                 launcher_flags += '-N %i ' % options.mpi
         self.launcher_flags = launcher_flags

     def get_output_prefix(self):
         if program_is_dirac:
             inp_file_strip = string.replace(os.path.split(self.inp)[1], '.inp', '')
         if program_is_dalton:
             inp_file_strip = string.replace(os.path.split(self.inp)[1], '.dal', '')
         mol_file_strip = string.replace(os.path.split(self.mol)[1], '.mol', '')
         mol_file_strip = string.replace(mol_file_strip, '.xyz', '')
         return '%s_%s' % (inp_file_strip, mol_file_strip)

     def get_test_name(self):
         (head,tail)=os.path.split(self.test)
         return tail
     def run_and_controlled_exit(self):
         def child_signaller(signum, frame):
             '''Pass on signals to the launcher to its children'''
             signum_kill=2 # for killing, prepare the strongest ammo
             if program_group_id is not None:
                 print('runtest: got signal #%s, passing #2 (SIGINT) on to children' % str(signum))
                 if sys.platform != 'win32':
                     os.killpg(program_group_id,signum_kill)
                 else:
                     kill_win(program_group_id)
                 if not executed_from_subdir:
                     # time delay for killing
                     # don't delay if this is interactive run from subdir
                     time.sleep(2)
             sys.exit()

         if sys.platform != 'win32':
             signal.signal(signal.SIGHUP,child_signaller)
             signal.signal(signal.SIGPIPE,child_signaller)
         else:
            signal.signal(signal.SIGABRT,child_signaller)
            signal.signal(signal.SIGFPE,child_signaller)
            signal.signal(signal.SIGILL,child_signaller)
            signal.signal(signal.SIGSEGV,child_signaller)

         signal.signal(signal.SIGTERM,child_signaller)
         signal.signal(signal.SIGINT,child_signaller)

         os.chdir(self.test)

         # run the launcher
         if program_is_dirac:
             launcher = os.path.join(root_directory, "pam")
             command = 'python ' + launcher + ' --inp=%s --mol=%s %s' % (self.inp, self.mol, self.launcher_flags)
         if program_is_dalton:
             if options.launcher:
                 launcher = options.launcher
             else:
                 launcher = os.path.join(root_directory, '../../build/dalton')
             # verify that launcher really exists
             if not os.path.isfile(launcher):
                 error_message = 'error: launcher not found in %s' % launcher
                 error_message += '\n       try to specify path to your launcher with ./runtest --launcher=path'
                 print(error_message)
                 sys.exit(1)

             output_prefix = '%s_%s' % (string.replace(self.inp, '.dal', ''), string.replace(self.mol, '.mol', ''))
             command = launcher + \
                 ' -d %s %s %s 1> %s.stdout 2> %s.stderr' % (self.launcher_flags, \
                                                             self.inp,            \
                                                             self.mol,            \
                                                             output_prefix,       \
                                                             output_prefix)

         if program_is_dirac:
             if sys.platform != 'win32':
                 p = subprocess.Popen(shlex.split(command),
                                      stdin=subprocess.PIPE,
                                      stdout=subprocess.PIPE,
                                      preexec_fn=os.setsid)
             else:
                 # instead shlex.split(command) use plain command on Windows
                 p = subprocess.Popen(command,
                                      stdin=subprocess.PIPE,
                                      stdout=subprocess.PIPE)
             program_group_id = p.pid # save DIRAC process group id for latter killing of subprocesses

         if program_is_dalton:
             os.system(command)

         if program_is_dirac:
             launcher_output = p.communicate()[0]
             normal_termination = ('exit           : normal' in launcher_output)
         if program_is_dalton:
             normal_termination = ('Total wall time used in DALTON' in open(self.get_output_prefix() + '.out').read())
         if normal_termination:
             return 'NORMAL'
         else:
             exit = 'CRASH'
             f = open(self.get_output_prefix() + '.out', 'r')
             s = f.readlines()
             for line in s:
                 if 'controlled stop: only sequential' in line:
                    if options.mpi > 1:
                        exit = 'SKIP'
                 if 'controlled stop: only int64' in line:
                    if int32_run(s):
                        exit = 'SKIP'
                 if 'controlled stop: only int32' in line:
                    if not int32_run(s):
                        exit = 'SKIP'
             f.close()
             return exit
     def print_result(self, progress, result_text, elapsed):
         """
          print result of the test
         """
         if program_is_dirac:
             inp_file_strip = string.replace(self.inp,       '.inp', '')
         if program_is_dalton:
             inp_file_strip = string.replace(self.inp,       '.dal', '')
         mol_file_strip = string.replace(self.mol,       '.mol', '')
         mol_file_strip = string.replace(mol_file_strip, '.xyz', '')

         elapsed_str = time.strftime('%Mm%Ss', time.gmtime(elapsed))

         print('%6s %10s %30s %35s %25s %s' % \
             (progress, result_text, self.get_test_name(),        \
              inp_file_strip, mol_file_strip, elapsed_str))

     def apply_filter(self, output_file, suffix):

         log_file   = open('compare/%s.diff' % output_file, 'w')
         own_result = open('compare/%s.own'  % output_file, 'w')
         ref_result = open('compare/%s.ref'  % output_file, 'w')

         # read filter and get list of filter tasks
         filter_task_l = read_filter('result/filter.%s' % suffix)

         # read output and reference output
         output     = open(            output_file).readlines()
         output_ref = open('result/' + output_file).readlines()

         for filter_task in filter_task_l:
             if filter_task.compare_everything:
                 line_l     = [range(len(output))]
                 line_l_ref = [range(len(output_ref))]
             elif filter_task.plus_nr_lines > 0:
                 line_l     = find_string_plus_nr_lines(output,                    \
                                                        filter_task.start_string,  \
                                                        filter_task.plus_nr_lines, \
                                                        start_is_regex=filter_task.start_is_regex)
                 line_l_ref = find_string_plus_nr_lines(output_ref,                \
                                                        filter_task.start_string,  \
                                                        filter_task.plus_nr_lines, \
                                                        start_is_regex=filter_task.start_is_regex)
             else:
                 line_l     = find_from_to(output,         \
                                           filter_task.start_string,   \
                                           filter_task.start_is_regex, \
                                           filter_task.end_string,     \
                                           filter_task.end_is_regex,   \
                                           filter_task.end_is_including)
                 line_l_ref = find_from_to(output_ref,     \
                                           filter_task.start_string,   \
                                           filter_task.start_is_regex, \
                                           filter_task.end_string,     \
                                           filter_task.end_is_regex,   \
                                           filter_task.end_is_including)

             if not (line_l == []):
                 # subtask did not filter anything
                 # this can happen since sometimes we use same filter
                 # for very different outputs
                 for x in line_l:
                     for line in x:
                         own_result.write(output[line])
                 for x in line_l_ref:
                     for line in x:
                         ref_result.write(output_ref[line])
                 extract_and_compare_floats(log_file,                 \
                                            output,                   \
                                            output_ref,               \
                                            line_l,                   \
                                            line_l_ref,               \
                                            filter_task.nr_of_floats, \
                                            filter_task.precision,    \
                                            filter_task.ignore_below_limit, \
                                            filter_task.ignore_sign)
         log_file.close()
         own_result.close()
         ref_result.close()

     def is_shell_command(self):
         return False
     def is_python_command(self):
         return False
     def is_run(self):
         return True

class shell_command:
     def __init__(self, test, line):
         self.test    = test
         self.command = line[2:]
     def execute(self):
         os.chdir(self.test)
         os.system(self.command)
     def is_shell_command(self):
         return True
     def is_run(self):
         return False

class python_command:
     def __init__(self, test, line):
         self.test    = test
         self.command_args = line[2:]
         self.command = line[:2]
     def execute(self):
         os.chdir(self.test)
         if self.command == 'cp' :
             src=self.command_args.split()[0]
             dest=self.command_args.split()[1]
             if len(self.command_args.split()) != 2:
                 sys.exit("must be two arguments for copying command! you have"+self.command_args)
             if os.path.isfile(src):
                 pass
                 shutil.copy(src, dest)
             else:
                 print "runtest warning: copied file "+src+" does not exist in "+self.test
         elif self.command == 'rm' :
             for dirac_file  in self.command_args.split():
                if os.path.isfile(dirac_file):
                    os.remove(dirac_file)
                else:
                    print "runtest warning: file for removing "+dirac_file+"does not exist!"
                    print "  check the test menu presciption: "+self.command+" "+self.command_args
         elif self.command == 'mv' :
             src=self.command_args.split()[0]
             dest=self.command_args.split()[1]
             if len(self.command_args.split()) != 2:
                 sys.exit("must be two arguments for moving command!")
             if os.path.isfile(src):
                 pass
                 shutil.move(src, dest)
             else:
                 print "runtest warning:  source file "+src+" does not exist for move!"
                 print "  check test menu presciption: "+self.command+" "+self.command_args
         else:
             print 'wrong command in menu:',self.command
             sys.exit("Wrong meta-command in menu ! Can be only rm/cp/mv ! check menu presciption:"+self.command+" "+self.command_args)
     def is_python_command(self):
         return True
     def is_shell_command(self):
         return False
     def is_run(self):
         return False

def use_this_line(current_section):
    if options.quick:
        if current_section == 'quick':
            return True
    elif options.benchmark:
        if current_section == 'benchmark':
            return True
    else:
        if current_section == 'quick':
            return True
        if current_section == 'regular':
            return True
    return False

def get_current_section(line, current_section):
    word = line.split()[0]
    if word in ['quick', 'regular', 'benchmark']:
        return word
    return current_section

def line_is_keyword(line):
    return line.split()[0] in ['sh', 'quick', 'regular', 'benchmark', 'cp', 'mv', 'rm']

# main function
def main(*args):

#  get list of tasks
    l = []
    for test in list_of_tests_to_run:
        os.chdir(test)
        file = 'menu'
        if os.path.isfile(file):
            f = open(file, 'r')
            current_section = 'regular'
            for line in f.readlines():
                if len(line.split()) > 0:
                    if line[0:1] != '#':
                        current_section = get_current_section(line, current_section)
                        if use_this_line(current_section):
                            if   line[0:2] == 'sh':
                                l.append(shell_command(test, line))
                            elif line[0:2] == 'cp':
                                l.append(python_command(test, line))
                                pass
                            elif line[0:2] == 'mv':
                                l.append(python_command(test, line))
                                pass
                            elif line[0:2] == 'rm':
                                l.append(python_command(test, line))
                                pass
                            else:
                                if not line_is_keyword(line):
                                    l.append(run(test, line, current_section[0]))
            f.close()
        else:
            print('WARNING: %s has no menu file' % test)

    # get number of actual runs

    total_nr_of_tests = 0
    for task in l:
        if task.is_run():
            total_nr_of_tests += 1

    # print screen header

    print('')
    print('%17s %30s %35s %25s %6s' % ('result', 'test', 'inp', 'mol/xyz', 'time'))
    print('')

    # run the tests

    nr_of_tests_done = 0
    nr_ok            = 0
    nr_crashed       = 0
    nr_skip          = 0
    nr_failed        = 0
    nr_without_ref   = 0
    nr_marked_noref  = 0
    nr_bad_filter    = 0
    global_elapsed   = 0.0

    for task in l:
        if task.is_shell_command() or task.is_python_command():
            task.execute()
        else:
            nr_of_tests_done += 1
            start = time.time()
            exit = task.run_and_controlled_exit()
            if exit == 'NORMAL':

                nr_problems = 0
                for filter_file in glob.glob(os.path.join('result', 'filter*')):
                    if nr_problems == 0:
                        suffix = filter_file.split('.')[-1]
                        output_file = task.get_output_prefix() + '.' + suffix

                        if os.path.isfile(os.path.join('result', output_file)):
                            if not os.path.isdir('compare'):
                                # create directory where outputs are compared
                                os.mkdir('compare')

                            task.apply_filter(output_file, suffix)

                            if not task.noref:
                                if os.path.getsize('compare/%s.own' % output_file) == 0:
                                    # filter does not produce anything
                                    result_text = 'BAD FILTER'
                                    nr_bad_filter += 1
                                    nr_problems += 1
                                else:
                                    if os.path.getsize('compare/%s.diff' % output_file) == 0:
                                        result_text = 'OK'
                                        nr_ok += 1
                                    else:
                                        result_text = 'FAIL'
                                        nr_failed += 1
                                        nr_problems += 1
                        else:
                            if task.noref:
                                result_text = '(noref)'
                                nr_marked_noref += 1
                            else:
                                result_text = 'NO REF'
                                nr_without_ref += 1
                                nr_problems += 1
            else:
                result_text = exit
                if exit == 'CRASH':
                    nr_crashed += 1
                if exit == 'SKIP':
                    nr_skip += 1

            elapsed = (time.time() - start)
            global_elapsed += elapsed

            progress = '[%3i%s]' % (100.0*float(nr_of_tests_done)/float(total_nr_of_tests), r'%')
            task.print_result(progress, result_text, elapsed)

            if options.showdiff:
                if result_text == 'FAIL':
                    os.system('more ' + os.path.join('compare', output_file + '.diff'))

            if ((nr_crashed > 0) or (nr_failed > 0)) and options.giveup:
                print('')
                print('cowardly gave up after the first problem')
                print('(fix your code or remove --giveup to continue)')
                sys.exit(1)

            if options.timeout:
                timeout = extract_time(options.timeout)
                if global_elapsed > timeout:
                    error_message = '\n Giving up runtest. Total allowed time of %s seconds exceeded.\n' % timeout
                    print(error_message)
                    sys.exit(1)

    print('')
    print('summary: %5i ok'                     % nr_ok)
    if nr_failed > 0:
         print('         %5i failed'            % nr_failed)
    if nr_crashed > 0:
         print('         %5i crashed'           % nr_crashed)
    if nr_skip > 0:
         print('         %5i skip (controlled exit)' % nr_skip)
    if nr_without_ref > 0:
         print('         %5i without reference' % nr_without_ref)
    if nr_bad_filter > 0:
         print('         %5i with bad filter'   % nr_bad_filter)
    if nr_marked_noref > 0:
         print('         %5i marked as noref'   % nr_marked_noref)
    print('')

    global_elapsed_str = time.strftime('%Hh%Mm%Ss', time.gmtime(global_elapsed))
    print('total time: %s\n' % global_elapsed_str)

    # return code
    if (nr_failed + nr_crashed + nr_without_ref + nr_bad_filter) > 0 :
        return 1
    else:
        return 0

# launch the main function
if __name__ == '__main__':
    sys.exit(main(*sys.argv))
